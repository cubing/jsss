{"version":3,"file":"index-03ee41f0.js","sources":["../../src/alg/debug.ts","../../src/alg/algorithm/alg-part.ts","../../src/alg/algorithm/block-move.ts","../../src/alg/operation.ts","../../src/alg/traversal.ts","../../src/alg/example.ts","../../src/alg/json.ts","../../src/alg/validation.ts","../../src/alg/parser/parser.js","../../src/alg/parser/index.ts","../../src/alg/keyboard.ts","../../src/alg/url.ts"],"sourcesContent":["type ReportingLevel = \"none\" | \"warn\" | \"error\";\nlet currentReportingLevel = \"warn\";\n\nconst MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nlet numWarned = 0;\n\n// TODO: Avoid creating the string message if it won't be used (e.g. by taking a function?).\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw new Error(msg);\n    case \"warn\":\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned + 1 === MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(level: ReportingLevel): void {\n  currentReportingLevel = level;\n}\n","import { reportTypeMismatch } from \"../debug\";\n\nexport type AlgPartType = string;\n\nexport abstract class AlgPart {\n  public abstract type: AlgPartType;\n}\n\n// type Constructor<T> = Function & { prototype: T }\nexport function matchesAlgType<T extends AlgPart>(a: any, t: AlgPartType): boolean {\n  return a.type === t;\n}\n\nexport function assertMatchesType<T extends AlgPart>(a: any, t: AlgPartType): T {\n  if (!matchesAlgType(a, t)) {\n    reportTypeMismatch(`Expected \"type\": \"${t}\", saw \"type\": \\\"${a.type}\\\".`);\n  }\n  return a;\n}\n\n// Assumes that every `AlgPart` is a `Unit` or a `Sequence`.\nexport function isUnit(a: AlgPart): boolean {\n  if (!(\"type\" in a)) {\n    return false;\n  }\n  return !matchesAlgType(a, \"sequence\");\n}\n\nexport function assertIsUnit(a: AlgPart): Unit {\n  if (!(\"type\" in a)) {\n    reportTypeMismatch(`Expected \"unit\", saw a value that was not an AlgPart.`);\n  }\n  if (matchesAlgType(a, \"sequence\")) {\n    reportTypeMismatch(`Expected unit, saw \"sequence\".`);\n  }\n  return a;\n}\n\nexport abstract class Unit extends AlgPart { }\n\nexport abstract class Move extends Unit { }\nexport abstract class Annotation extends Unit { }\nexport abstract class Container extends Unit { }\n\n// TODO: Reintroduce an Algorithm class, and allow a mutable sequence too?\nexport class Sequence extends AlgPart {\n  public type: string = \"sequence\";\n  constructor(public nestedUnits: Unit[]) {\n    super();\n    for (const n of nestedUnits) {\n      assertIsUnit(n);\n    }\n    Object.freeze(this.nestedUnits);\n    Object.freeze(this);\n  }\n}\n\nexport interface WithAmount {\n  // TODO: Allow `amount` to be `undefined`, to distinguish between R and R1?\n  amount: number;\n}\nexport class Group extends Container implements WithAmount {\n  public type: string = \"group\";\n  constructor(public nestedSequence: Sequence, public amount: number = 1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Commutator extends Container implements WithAmount {\n  public type: string = \"commutator\";\n  constructor(public A: Sequence, public B: Sequence, public amount: number = 1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Conjugate extends Container implements WithAmount {\n  public type: string = \"conjugate\";\n  constructor(public A: Sequence, public B: Sequence, public amount: number = 1) {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class Pause extends Move {\n  public type: string = \"pause\";\n  constructor() {\n    super();\n    Object.freeze(this);\n  }\n}\nexport class NewLine extends Annotation {\n  public type: string = \"newLine\";\n  constructor() {\n    super();\n    Object.freeze(this);\n  }\n}\n\n// TODO: must be followed by a newline, unless at the end of an alg?\nexport class Comment extends Annotation {\n  public type: string = \"comment\";\n  constructor(public comment: string) {\n    super();\n    Object.freeze(this);\n  }\n}\n\n// TODO\n// export class TimeStamp extends AlgPart implements AlgPart\n","import { Move } from \"./alg-part\";\n\nexport type MoveFamily = string; // TODO: Convert to an enum with string mappings.\n\n// TODO: Rename to `LetterMove`?\nexport class BlockMove extends Move {\n  public type: string = \"blockMove\";\n\n  // If `outerLayer` is set, `innerLayer` must also be set.\n  public outerLayer?: number;\n  public innerLayer?: number;\n  constructor(outerLayer: number | undefined, innerLayer: number | undefined, public family: MoveFamily, public amount: number = 1) {\n    super();\n    if (innerLayer) {\n      this.innerLayer = innerLayer;\n      if (outerLayer) {\n        this.outerLayer = outerLayer;\n      }\n    }\n    if (outerLayer && !innerLayer) {\n      throw new Error(\"Attempted to contruct block move with outer layer but no inner layer\");\n    }\n    Object.freeze(this);\n  }\n}\n\nexport function BareBlockMove(family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(undefined, undefined, family, amount);\n}\n\nexport function LayerBlockMove(innerLayer: number, family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(undefined, innerLayer, family, amount);\n}\n\nexport function RangeBlockMove(outerLayer: number, innerLayer: number, family: MoveFamily, amount?: number): BlockMove {\n  return new BlockMove(outerLayer, innerLayer, family, amount);\n}\n","import { BlockMove, Sequence } from \"./algorithm\";\n\nfunction canCoalesce(m1: BlockMove, m2: BlockMove): boolean {\n  return m1.family === m2.family && m1.innerLayer === m2.innerLayer && m1.outerLayer === m2.outerLayer;\n}\n\ninterface BlockMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\nexport function modifiedBlockMove(original: BlockMove, modifications: BlockMoveModifications): BlockMove {\n  // TODO: use the nullish coalescing operator once it becomes available to us.\n  return new BlockMove(\n    modifications.outerLayer ?? original.outerLayer,\n    modifications.innerLayer ?? original.innerLayer,\n    modifications.family ?? original.family,\n    modifications.amount ?? original.amount,\n  );\n}\n\nexport function experimentalAppendBlockMove(s: Sequence, newMove: BlockMove, coalesceLastMove: boolean = false, mod: number = 0): Sequence {\n  const oldNestedUnits = s.nestedUnits;\n  const oldLastMove = oldNestedUnits[oldNestedUnits.length - 1] as (BlockMove | null);\n  if (coalesceLastMove && oldLastMove && canCoalesce(oldLastMove, newMove)) {\n    const newNestedUnits = s.nestedUnits.slice(0, oldNestedUnits.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    if (mod > 1) {\n      newAmount = (newAmount % mod + mod) % mod ;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod ;\n      }\n    }\n    if (newAmount !== 0) {\n      newNestedUnits.push(modifiedBlockMove(oldLastMove, { amount: newAmount }));\n    }\n    return new Sequence(newNestedUnits);\n  } else {\n    return new Sequence([...oldNestedUnits, newMove]);\n  }\n}\n\n// This purposely takes sequences as individual arguments, instead of a lsit of sequences, because:\n//\n// 1. This matches Javascript's built-in `Array.concat()` functionality.\n// 2. It encourages avoiding lists of sequences (which might lead to coding mistakes).\n//\n// TODO: Now useful is it to coalesce at alg boundaries (rather than coalescing the whole result)?\n// Should that be a separate function, or should we change this to accept coalescing option arg like `experimentalAppendBlockMove()`?\nexport function experimentalConcatAlgs(...args: Sequence[]): Sequence {\n  return new Sequence(Array.prototype.concat.apply([], [...args].map((s) => s.nestedUnits)));\n}\n","import { assertIsUnit, assertMatchesType, isUnit, matchesAlgType } from \"./algorithm/alg-part\";\n\nimport {\n  AlgPart,\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  Unit,\n  WithAmount,\n} from \"./algorithm\";\n\nfunction dispatch<DataDown, DataUp>(t: TraversalDownUp<DataDown, DataUp>, algPart: AlgPart, dataDown: DataDown): DataUp {\n  switch (algPart.type) {\n    case \"sequence\":\n      assertMatchesType(algPart, \"sequence\");\n      return t.traverseSequence(algPart as Sequence, dataDown);\n    case \"group\":\n      assertMatchesType(algPart, \"group\");\n      return t.traverseGroup(algPart as Group, dataDown);\n    case \"blockMove\":\n      assertMatchesType(algPart, \"blockMove\");\n      return t.traverseBlockMove(algPart as BlockMove, dataDown);\n    case \"commutator\":\n      assertMatchesType(algPart, \"commutator\");\n      return t.traverseCommutator(algPart as Commutator, dataDown);\n    case \"conjugate\":\n      assertMatchesType(algPart, \"conjugate\");\n      return t.traverseConjugate(algPart as Conjugate, dataDown);\n    case \"pause\":\n      assertMatchesType(algPart, \"pause\");\n      return t.traversePause(algPart as Pause, dataDown);\n    case \"newLine\":\n      assertMatchesType(algPart, \"newLine\");\n      return t.traverseNewLine(algPart as NewLine, dataDown);\n    case \"comment\":\n      assertMatchesType(algPart, \"comment\");\n      return t.traverseComment(algPart as Comment, dataDown);\n    default:\n      throw new Error(`Unknown AlgPart type: ${algPart.type}`);\n  }\n}\n\nexport abstract class TraversalDownUp<DataDown, DataUp> {\n  // Immediate subclasses should overwrite this.\n  public traverse(algPart: AlgPart, dataDown: DataDown): DataUp {\n    return dispatch(this, algPart, dataDown);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart, dataDown: DataDown): Unit {\n    return assertIsUnit(this.traverse(algPart, dataDown) as any);\n  }\n\n  public abstract traverseSequence(sequence: Sequence, dataDown: DataDown): DataUp;\n  public abstract traverseGroup(group: Group, dataDown: DataDown): DataUp;\n  public abstract traverseBlockMove(blockMove: BlockMove, dataDown: DataDown): DataUp;\n  public abstract traverseCommutator(commutator: Commutator, dataDown: DataDown): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate, dataDown: DataDown): DataUp;\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUp;\n  public abstract traverseNewLine(newLine: NewLine, dataDown: DataDown): DataUp;\n  public abstract traverseComment(comment: Comment, dataDown: DataDown): DataUp;\n}\n\nexport abstract class TraversalUp<DataUp> extends TraversalDownUp<undefined, DataUp> {\n  public traverse(algPart: AlgPart): DataUp {\n    return dispatch<undefined, DataUp>(this, algPart, undefined);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart): Unit {\n    return assertIsUnit(this.traverse(algPart) as any);\n  }\n\n  public abstract traverseSequence(sequence: Sequence): DataUp;\n  public abstract traverseGroup(group: Group): DataUp;\n  public abstract traverseBlockMove(blockMove: BlockMove): DataUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUp;\n  public abstract traversePause(pause: Pause): DataUp;\n  public abstract traverseNewLine(newLine: NewLine): DataUp;\n  public abstract traverseComment(comment: Comment): DataUp;\n}\n\n// TODO: Test that inverses are bijections.\nexport class Invert extends TraversalUp<AlgPart> {\n  public traverseSequence(sequence: Sequence): Sequence {\n    // TODO: Handle newLines and comments correctly\n    return new Sequence(sequence.nestedUnits.slice().reverse().map((a) => this.traverseIntoUnit(a)));\n  }\n  public traverseGroup(group: Group): AlgPart {\n    return new Group(this.traverseSequence(group.nestedSequence), group.amount);\n  }\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return new BlockMove(blockMove.outerLayer, blockMove.innerLayer, blockMove.family, -blockMove.amount);\n  }\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    return new Commutator(commutator.B, commutator.A, commutator.amount);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    return new Conjugate(conjugate.A, this.traverseSequence(conjugate.B), conjugate.amount);\n  }\n  public traversePause(pause: Pause): AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine): AlgPart { return newLine; }\n  public traverseComment(comment: Comment): AlgPart { return comment; }\n}\n\nexport class Expand extends TraversalUp<AlgPart> {\n\n  public traverseSequence(sequence: Sequence): Sequence {\n    return new Sequence(this.flattenSequenceOneLevel(sequence.nestedUnits.map((a) => this.traverse(a))));\n  }\n  public traverseGroup(group: Group): AlgPart {\n    // TODO: Pass raw AlgPart[] to sequence.\n    return this.repeat(this.flattenSequenceOneLevel([this.traverse(group.nestedSequence)]), group);\n  }\n  public traverseBlockMove(blockMove: BlockMove): AlgPart {\n    return blockMove;\n  }\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    const expandedA = this.traverseSequence(commutator.A);\n    const expandedB = this.traverseSequence(commutator.B);\n    let once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA),\n      invert(expandedB),\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), commutator);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    const expandedA = this.traverseSequence(conjugate.A);\n    const expandedB = this.traverseSequence(conjugate.B);\n    let once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA),\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), conjugate);\n  }\n  public traversePause(pause: Pause): AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine): AlgPart { return newLine; }\n  public traverseComment(comment: Comment): AlgPart { return comment; }\n  private flattenSequenceOneLevel(algList: AlgPart[]): Unit[] {\n    let flattened: Unit[] = [];\n    for (const part of algList) {\n      if (matchesAlgType(part, \"sequence\")) {\n        flattened = flattened.concat((part as Sequence).nestedUnits);\n      } else if (isUnit(part)) {\n        flattened.push(part);\n      } else {\n        throw new Error(\"expand() encountered an internal error. Did you pass in a valid Algorithm?\");\n      }\n    }\n    return flattened;\n  }\n\n  private repeat(algList: Unit[], accordingTo: WithAmount): Sequence {\n    const amount = Math.abs(accordingTo.amount);\n    const amountDir = (accordingTo.amount > 0) ? 1 : -1; // Mutable\n\n    // TODO: Cleaner inversion\n    let once: Unit[];\n    if (amountDir === -1) {\n      // TODO: Avoid casting to sequence.\n      once = ((invert(new Sequence(algList))) as Sequence).nestedUnits;\n    } else {\n      once = algList;\n    }\n\n    let repeated: Unit[] = [];\n    for (let i = 0; i < amount; i++) {\n      repeated = repeated.concat(once);\n    }\n\n    return new Sequence(repeated);\n  }\n}\n\nexport class StructureEquals extends TraversalDownUp<AlgPart, boolean> {\n  public traverseSequence(sequence: Sequence, dataDown: AlgPart): boolean {\n    if (isUnit(dataDown)) {\n      return false;\n    }\n    const dataDownSeq = dataDown as Sequence;\n    if (sequence.nestedUnits.length !== dataDownSeq.nestedUnits.length) {\n      return false;\n    }\n    for (let i = 0; i < sequence.nestedUnits.length; i++) {\n      if (!this.traverse(sequence.nestedUnits[i], dataDownSeq.nestedUnits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public traverseGroup(group: Group, dataDown: AlgPart): boolean {\n    return (matchesAlgType(dataDown, \"group\")) && this.traverse(group.nestedSequence, (dataDown as Group).nestedSequence);\n  }\n  public traverseBlockMove(blockMove: BlockMove, dataDown: AlgPart): boolean {\n    // TODO: Handle layers.\n    return matchesAlgType(dataDown, \"blockMove\") &&\n      blockMove.outerLayer === (dataDown as BlockMove).outerLayer &&\n      blockMove.innerLayer === (dataDown as BlockMove).innerLayer &&\n      blockMove.family === (dataDown as BlockMove).family &&\n      blockMove.amount === (dataDown as BlockMove).amount;\n  }\n  public traverseCommutator(commutator: Commutator, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"commutator\") &&\n      this.traverse(commutator.A, (dataDown as Commutator).A) &&\n      this.traverse(commutator.B, (dataDown as Commutator).B);\n  }\n  public traverseConjugate(conjugate: Conjugate, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"conjugate\") &&\n      this.traverse(conjugate.A, (dataDown as Conjugate).A) &&\n      this.traverse(conjugate.B, (dataDown as Conjugate).B);\n  }\n  public traversePause(pause: Pause, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"pause\");\n  }\n  public traverseNewLine(newLine: NewLine, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"newLine\");\n  }\n  public traverseComment(comment: Comment, dataDown: AlgPart): boolean {\n    return matchesAlgType(dataDown, \"comment\") && (comment.comment === (dataDown as Comment).comment);\n  }\n}\n\n// TODO: Test that inverses are bijections.\nexport class CoalesceBaseMoves extends TraversalUp<AlgPart> {\n\n  // TODO: Handle\n  public traverseSequence(sequence: Sequence): Sequence {\n    const coalesced: Unit[] = [];\n    for (const part of sequence.nestedUnits) {\n      if (!matchesAlgType(part, \"blockMove\")) {\n        coalesced.push(this.traverseIntoUnit(part));\n      } else if (coalesced.length > 0) {\n        const last = coalesced[coalesced.length - 1];\n        if (matchesAlgType(last, \"blockMove\") &&\n          this.sameBlock((last as BlockMove), (part as BlockMove))) {\n          // TODO: This is cube-specific. Perhaps pass the modules as DataDown?\n          const amount = (last as BlockMove).amount + (part as BlockMove).amount;\n          coalesced.pop();\n          if (amount !== 0) {\n            // We could modify the last element instead of creating a new one,\n            // but this is safe against shifting coding practices.\n            // TODO: Figure out if the shoot-in-the-foot risk\n            // modification is worth the speed.\n            coalesced.push(new BlockMove((part as BlockMove).outerLayer, (part as BlockMove).innerLayer, (part as BlockMove).family, amount));\n          }\n        } else {\n          coalesced.push(part);\n        }\n      } else {\n        coalesced.push(part);\n      }\n    }\n    return new Sequence(coalesced);\n  }\n  public traverseGroup(group: Group): AlgPart { return group; }\n  public traverseBlockMove(blockMove: BlockMove): AlgPart { return blockMove; }\n  public traverseCommutator(commutator: Commutator): AlgPart { return commutator; }\n  public traverseConjugate(conjugate: Conjugate): AlgPart { return conjugate; }\n  public traversePause(pause: Pause): AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine): AlgPart { return newLine; }\n  public traverseComment(comment: Comment): AlgPart { return comment; }\n  private sameBlock(moveA: BlockMove, moveB: BlockMove): boolean {\n    // TODO: Handle layers\n    return moveA.outerLayer === moveB.outerLayer &&\n      moveA.innerLayer === moveB.innerLayer &&\n      moveA.family === moveB.family;\n  }\n}\n\n// export class Concat extends TraversalDownUp<Algorithm, Sequence> {\n//   private concatIntoSequence(A: Unit[], B: Algorithm): Sequence {\n//     var nestedAlgs: Unit[] = A.slice();\n//     if (matchesAlgType(B, \"sequence\")) {\n//       nestedAlgs = nestedAlgs.concat((B as unknown as Sequence).nestedUnits)\n//     } else {\n//       nestedAlgs.push(B as unknown as Unit);\n//     }\n//     return new Sequence(nestedAlgs)\n//   }\n//   public traverseSequence(     sequence:     Sequence,     dataDown: Algorithm): Sequence {return this.concatIntoSequence(sequence.nestedUnits, dataDown); }\n//   public traverseGroup(        group:        Group,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([group]          , dataDown); }\n//   public traverseBlockMove(    BlockMove:    BlockMove,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([BlockMove]      , dataDown); }\n//   public traverseCommutator(   commutator:   Commutator,   dataDown: Algorithm): Sequence {return this.concatIntoSequence([commutator]     , dataDown); }\n//   public traverseConjugate(    conjugate:    Conjugate,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([conjugate]      , dataDown); }\n//   public traversePause(        pause:        Pause,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([pause]          , dataDown); }\n//   public traverseNewLine(      newLine:      NewLine,      dataDown: Algorithm): Sequence {return this.concatIntoSequence([newLine]        , dataDown); }\n//   public traverseComment( comment: Comment, dataDown: Algorithm): Sequence {return this.concatIntoSequence([comment]   , dataDown); }\n// }\n\nfunction repetitionSuffix(amount: number): string {\n  const absAmount = Math.abs(amount);\n  let s = \"\";\n  if (absAmount !== 1) {\n    s += String(absAmount);\n  }\n  if (absAmount !== amount) {\n    s += \"'\";\n  }\n  return s;\n}\nexport function blockMoveToString(blockMove: BlockMove): string {\n  let out = blockMove.family + repetitionSuffix(blockMove.amount);\n  if (typeof blockMove.innerLayer !== \"undefined\") {\n    out = String(blockMove.innerLayer) + out;\n    if (typeof blockMove.outerLayer !== \"undefined\") {\n      out = String(blockMove.outerLayer) + \"-\" + out;\n    }\n  }\n  return out;\n}\n\nexport class ToString extends TraversalUp<string> {\n  public traverseSequence(sequence: Sequence): string {\n    let output = \"\";\n    if (sequence.nestedUnits.length > 0) {\n      output += this.traverse(sequence.nestedUnits[0]);\n      for (let i = 1; i < sequence.nestedUnits.length; i++) {\n        output += this.spaceBetween(sequence.nestedUnits[i - 1], sequence.nestedUnits[i]);\n        output += this.traverse(sequence.nestedUnits[i]);\n      }\n    }\n    return output;\n  }\n  public traverseGroup(group: Group): string { return \"(\" + this.traverse(group.nestedSequence) + \")\" + repetitionSuffix(group.amount); }\n  public traverseBlockMove(blockMove: BlockMove): string {\n    return blockMoveToString(blockMove);\n  }\n  public traverseCommutator(commutator: Commutator): string { return \"[\" + this.traverse(commutator.A) + \", \" + this.traverse(commutator.B) + \"]\" + repetitionSuffix(commutator.amount); }\n  public traverseConjugate(conjugate: Conjugate): string { return \"[\" + this.traverse(conjugate.A) + \": \" + this.traverse(conjugate.B) + \"]\" + repetitionSuffix(conjugate.amount); }\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(pause: Pause): string { return \".\"; }\n  public traverseNewLine(newLine: NewLine): string { return \"\\n\"; }\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseComment(comment: Comment): string { return \"//\" + comment.comment; }\n  // TODO: Sanitize `*/`\n  private spaceBetween(u1: Unit, u2: Unit): string {\n    if (matchesAlgType(u1, \"pause\") && matchesAlgType(u2, \"pause\")) {\n      return \"\";\n    }\n    if (matchesAlgType(u1, \"newLine\") || matchesAlgType(u2, \"newLine\")) {\n      return \"\";\n    }\n    if (matchesAlgType(u1, \"comment\") && !matchesAlgType(u2, \"newLine\")) {\n      return \"\\n\";\n    }\n    return \" \";\n  }\n}\n\nconst invertInstance = new Invert();\nconst expandInstance = new Expand();\nconst structureEqualsInstance = new StructureEquals();\nconst coalesceBaseMovesInstance = new CoalesceBaseMoves();\nconst algToStringInstance = new ToString();\n\nexport const invert = invertInstance.traverseSequence.bind(invertInstance) as (a: Sequence) => Sequence;\nexport const expand = expandInstance.traverseSequence.bind(expandInstance) as (a: Sequence) => Sequence;\nexport const structureEquals = structureEqualsInstance.traverseSequence.bind(structureEqualsInstance) as (a1: Sequence, a2: Sequence) => boolean;\nexport const coalesceBaseMoves = coalesceBaseMovesInstance.traverseSequence.bind(coalesceBaseMovesInstance) as (a: Sequence) => Sequence;\nexport const algToString = algToStringInstance.traverseSequence.bind(algToStringInstance) as (a: Sequence) => string;\n\nexport const algPartStructureEqualsForTesting = algToStringInstance.traverse.bind(algToStringInstance) as (a1: AlgPart, a2: AlgPart) => boolean;\nexport const algPartToStringForTesting = algToStringInstance.traverse.bind(algToStringInstance) as (a: AlgPart) => string;\n\nexport function experimentalBlockMoveQuantumName(move: BlockMove): string {\n  return algPartToStringForTesting(new BlockMove(move.outerLayer, move.innerLayer, move.family, 1));\n}\n","import {\n  AlgPart,\n  BareBlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n} from \"./algorithm\";\n\n// tslint:disable-next-line no-namespace // TODO: nested module\nexport namespace Example {\n\n  export const Sune: Sequence = new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -2),\n    BareBlockMove(\"R\", -1),\n  ]);\n\n  export const AntiSune: Sequence = new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 2),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n  ]);\n\n  export const SuneCommutator: Sequence = new Sequence([new Commutator(\n    new Sequence([\n      BareBlockMove(\"R\", 1),\n      BareBlockMove(\"U\", 1),\n      BareBlockMove(\"R\", -2),\n    ]),\n    new Sequence([new Conjugate(\n      new Sequence([BareBlockMove(\"R\", 1)]),\n      new Sequence([BareBlockMove(\"U\", 1)]),\n      1,\n    )]),\n    1,\n  )]);\n\n  export const Niklas: Sequence = new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"L\", -1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"L\", 1),\n    BareBlockMove(\"U\", 1),\n  ]);\n\n  export const EPerm: Sequence = new Sequence([\n    BareBlockMove(\"x\", -1),\n    new Commutator(\n      new Sequence([new Conjugate(\n        new Sequence([BareBlockMove(\"R\", 1)]),\n        new Sequence([BareBlockMove(\"U\", -1)]),\n      )]),\n      new Sequence([BareBlockMove(\"D\", 1)]),\n      1,\n    ),\n    new Commutator(\n      new Sequence([new Conjugate(\n        new Sequence([BareBlockMove(\"R\", 1)]),\n        new Sequence([BareBlockMove(\"U\", 1)]),\n      )]),\n      new Sequence([BareBlockMove(\"D\", 1)]),\n      1,\n    ),\n    BareBlockMove(\"x\", 1),\n  ]);\n\n  export const FURURFCompact: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"F\", 1)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"U\", 1)]),\n      new Sequence([BareBlockMove(\"R\", 1)]),\n      1,\n    )]),\n    1,\n  )]);\n\n  export const APermCompact: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"R\", 2)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"F\", 2)]),\n      new Sequence([\n        BareBlockMove(\"R\", -1),\n        BareBlockMove(\"B\", -1),\n        BareBlockMove(\"R\", 1),\n      ]),\n      1,\n    )]),\n    1,\n  )]);\n\n  export const FURURFMoves: Sequence = new Sequence([\n    BareBlockMove(\"F\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", -1),\n  ]);\n\n  export const TPerm: Sequence = new Sequence([\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", 1),\n    BareBlockMove(\"R\", 2),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"U\", -1),\n    BareBlockMove(\"R\", 1),\n    BareBlockMove(\"U\", 1),\n    BareBlockMove(\"R\", -1),\n    BareBlockMove(\"F\", -1),\n  ]);\n\n  export const HeadlightSwaps: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareBlockMove(\"F\", 1)]),\n    new Sequence([new Commutator(\n      new Sequence([BareBlockMove(\"R\", 1)]),\n      new Sequence([BareBlockMove(\"U\", 1)]),\n      3,\n    )]),\n    1,\n  )]);\n\n  export const TriplePause: Sequence = new Sequence([\n    new Pause(),\n    new Pause(),\n    new Pause(),\n  ],\n  );\n\n  export const AllAlgParts: AlgPart[] = [\n    new Sequence([BareBlockMove(\"R\", 1), BareBlockMove(\"U\", -1)]),\n    new Group(new Sequence([BareBlockMove(\"F\", 1)]), 2),\n    // new Rotation(\"y\", -1),\n    BareBlockMove(\"R\", 2),\n    new Commutator(new Sequence([BareBlockMove(\"R\", 2)]), new Sequence([BareBlockMove(\"U\", 2)]), 2),\n    new Conjugate(new Sequence([BareBlockMove(\"L\", 2)]), new Sequence([BareBlockMove(\"D\", -1)]), 2),\n    new Pause(),\n    new NewLine(),\n    new Comment(\"short comment\"),\n  ];\n\n}\n","import {\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n  Unit,\n} from \"./algorithm\";\n\n// TODO: Turn this into a union.\nexport interface AlgJSON {\n  type: string;\n  nestedSequence?: AlgJSON;\n  nestedUnits?: AlgJSON[];\n  innerLayer?: number;\n  outerLayer?: number;\n  family?: string;\n  amount?: number;\n  A?: AlgJSON;\n  B?: AlgJSON;\n  comment?: string;\n}\n\nexport function fromJSON(json: AlgJSON): Sequence {\n  if (json.type !== \"sequence\") {\n    throw new Error(`Expected Sequence while parsing, got: ${json.type}`);\n  }\n  if (!json.nestedUnits) { throw new Error(\"Missing nestedUnits\"); }\n  return new Sequence(json.nestedUnits.map((j) => unitFromJSON(j)));\n}\n\nfunction unitFromJSON(json: AlgJSON): Unit {\n  switch (json.type) {\n    case \"sequence\":\n      throw new Error(`Expected AlgPart while parsing, got \\`Sequence\\`.`);\n    case \"group\":\n      if (!json.nestedSequence) { throw new Error(\"Missing nestedSequence\"); }\n      if (!json.amount) { throw new Error(\"Missing amount\"); }\n      return new Group(fromJSON(json.nestedSequence), json.amount);\n    case \"blockMove\":\n      // TODO: Double-check that there is no outer layer without an inner layer?\n      if (!json.family) { throw new Error(\"Missing family\"); }\n      if (!json.amount) { throw new Error(\"Missing amount\"); }\n      return new BlockMove(json.outerLayer, json.innerLayer, json.family, json.amount);\n    case \"commutator\":\n      if (!json.A) { throw new Error(\"Missing A\"); }\n      if (!json.B) { throw new Error(\"Missing B\"); }\n      if (!json.amount) { throw new Error(\"Missing amount\"); }\n      return new Commutator(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"conjugate\":\n      if (!json.A) { throw new Error(\"Missing A\"); }\n      if (!json.B) { throw new Error(\"Missing B\"); }\n      if (!json.amount) { throw new Error(\"Missing amount\"); }\n      return new Conjugate(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"pause\":\n      return new Pause();\n    case \"newLine\":\n      return new NewLine();\n    case \"comment\":\n      // The empty string is nullish, so we check for it separately.\n      if (!json.comment && json.comment !== \"\") { throw new Error(\"Missing comment\"); }\n      return new Comment(json.comment);\n    default:\n      throw new Error(`Unknown alg type: ${json.type}`);\n  }\n}\n","import {\n  BlockMove,\n  Comment,\n  Commutator,\n  Conjugate,\n  Group,\n  NewLine,\n  Pause,\n  Sequence,\n} from \"./algorithm\";\n\nimport { TraversalUp } from \"./traversal\";\n\nexport class ValidationError extends Error { }\n\nexport abstract class ValidatorTraversal extends TraversalUp<void> { }\n\ninterface FamilyList { [s: string]: boolean; }\n\nfunction validateFamily(family: string, allowedFamilyLists: FamilyList[]): boolean {\n  for (const list of allowedFamilyLists) {\n    if (list[family] === true) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO: Switch to `Set`?\nconst plainMoveFamilies: FamilyList = {\n  x: true,\n  y: true,\n  z: true,\n  M: true,\n  E: true,\n  S: true,\n  m: true,\n  e: true,\n  s: true,\n};\n\nconst singleSliceMoveFamilies: FamilyList = {\n  U: true,\n  L: true,\n  F: true,\n  R: true,\n  B: true,\n  D: true,\n};\n\nconst wideMoveFamilies: FamilyList = {\n  u: true,\n  l: true,\n  f: true,\n  r: true,\n  b: true,\n  d: true,\n  Uw: true,\n  Lw: true,\n  Fw: true,\n  Rw: true,\n  Bw: true,\n  Dw: true,\n};\n\nabstract class BaseMoveValidator extends ValidatorTraversal {\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (const unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n  }\n  public traverseGroup(group: Group): void {\n    return this.traverse(group.nestedSequence);\n  }\n  public traverseCommutator(commutator: Commutator): void {\n    this.traverse(commutator.A);\n    this.traverse(commutator.B);\n  }\n  public traverseConjugate(conjugate: Conjugate): void {\n    this.traverse(conjugate.A);\n    this.traverse(conjugate.B);\n  }\n  public traversePause(pause: Pause): void { return; }\n  public traverseNewLine(newLine: NewLine): void { return; }\n  public traverseComment(comment: Comment): void { return; }\n}\n\n// TODO: Export function instead?\nexport class BlockMoveValidator extends BaseMoveValidator {\n  public traverseBlockMove(blockMove: BlockMove): void {\n    if (typeof blockMove.outerLayer !== \"undefined\") {\n      if (typeof blockMove.innerLayer === \"undefined\") {\n        throw new ValidationError(\"A BlockMove with an outer layer must have an inner layer.\");\n      }\n      if (!validateFamily(blockMove.family, [wideMoveFamilies])) {\n        throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an outer and inner layer: ${blockMove.family}`);\n      }\n      if (blockMove.outerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an outer layer of 0 or less.\");\n      }\n      // TODO: Allow 2-2r?\n      if (blockMove.outerLayer >= blockMove.innerLayer) {\n        throw new ValidationError(\"The outer layer must be less than the inner layer.\");\n      }\n      return;\n    } else if (typeof blockMove.innerLayer !== \"undefined\") {\n      if (!validateFamily(blockMove.family, [wideMoveFamilies, singleSliceMoveFamilies])) {\n        throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an inner slice: ${blockMove.family}`);\n      }\n      if (blockMove.innerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an inner layer of 0 or less.\");\n      }\n      return;\n    } else {\n      if (!validateFamily(blockMove.family, [wideMoveFamilies, singleSliceMoveFamilies, plainMoveFamilies])) {\n        throw new ValidationError(`Invalid SiGN plain move family: ${blockMove.family}`);\n      }\n      return;\n    }\n  }\n}\n\n// TODO: Export function instead?\nexport class FlatAlgValidator extends ValidatorTraversal {\n\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (const unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n    return;\n  }\n  public traverseGroup(group: Group): void {\n    throw new ValidationError(\"A flat alg cannot contain a group.\");\n  }\n  public traverseBlockMove(blockMove: BlockMove): void {\n    return;\n  }\n  public traverseCommutator(commutator: Commutator): void {\n    throw new ValidationError(\"A flat alg cannot contain a commutator.\");\n  }\n  public traverseConjugate(conjugate: Conjugate): void {\n    throw new ValidationError(\"A flat alg cannot contain a conjugate.\");\n  }\n  public traversePause(pause: Pause): void { return; }\n  public traverseNewLine(newLine: NewLine): void { return; }\n  public traverseComment(comment: Comment): void { return; }\n}\n\nexport type Validator = (a: Sequence) => void;\n\nconst BlockMoveValidatorInstance = new BlockMoveValidator();\nexport const validateSiGNMoves = BlockMoveValidatorInstance.traverse.bind(BlockMoveValidatorInstance) as Validator;\n\nconst flatAlgValidatorInstance = new FlatAlgValidator();\nexport const validateFlatAlg = flatAlgValidatorInstance.traverse.bind(flatAlgValidatorInstance) as Validator;\n\n// TODO: Option for puzzle size?\nexport function validateSiGNAlg(a: Sequence): void {\n  validateSiGNMoves(a);\n  validateFlatAlg(a);\n}\n","// Workaround per https://github.com/pegjs/pegjs/pull/481\nimport parser from \"./parser.pegjs\";\nconst {parse} = parser;\nexport {parse};\n","import { Sequence } from \"../algorithm\";\nimport { fromJSON } from \"../json\";\nimport { validateSiGNAlg, Validator } from \"../validation\";\nimport { parse as pegParse } from \"./parser\";\n\nexport interface ParseOptions {\n  validators?: Validator[];\n}\n\n// TODO: Include token location info.\n// TODO: Take validators in a way that allows optimizing parsing.\nexport function parse(s: string, options: ParseOptions = { validators: [] }): Sequence {\n  options.validators = options.validators || [];\n\n  const algo = fromJSON(pegParse(s));\n  for (const validate of options.validators) {\n    validate(algo);\n  }\n  return algo;\n}\n\nexport function parseSiGN(s: string): Sequence {\n  return parse(s, { validators: [validateSiGNAlg] });\n}\n","import { BareBlockMove, BlockMove } from \"./algorithm\";\n\nconst cubeKeyMapping: { [key: number]: BlockMove } = {\n  73: BareBlockMove(\"R\"), 75: BareBlockMove(\"R\", -1),\n  87: BareBlockMove(\"B\"), 79: BareBlockMove(\"B\", -1),\n  83: BareBlockMove(\"D\"), 76: BareBlockMove(\"D\", -1),\n  68: BareBlockMove(\"L\"), 69: BareBlockMove(\"L\", -1),\n  74: BareBlockMove(\"U\"), 70: BareBlockMove(\"U\", -1),\n  72: BareBlockMove(\"F\"), 71: BareBlockMove(\"F\", -1), // Heise\n  78: BareBlockMove(\"F\"), 86: BareBlockMove(\"F\", -1), // Kirjava\n\n  67: BareBlockMove(\"l\"), 82: BareBlockMove(\"l\", -1),\n  85: BareBlockMove(\"r\"), 77: BareBlockMove(\"r\", -1),\n\n  84: BareBlockMove(\"x\"), 89: BareBlockMove(\"x\"), 66: BareBlockMove(\"x\", -1), // 84 (T) and 89 (Y) are alternatives.\n  186: BareBlockMove(\"y\"), 59: BareBlockMove(\"y\"), 65: BareBlockMove(\"y\", -1), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: BareBlockMove(\"z\"), 81: BareBlockMove(\"z\", -1),\n\n  190: BareBlockMove(\"M\", -1),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): BlockMove | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n","import { Sequence } from \"./algorithm\";\nimport { parse } from \"./parser\";\nimport { algToString } from \"./traversal\";\n\n// This is not the most sophisticated scheme, but it has been used in production\n// at alg.cubing.net for years.\nexport function serializeURLParam(a: Sequence): string {\n  let escaped = algToString(a);\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\n\nexport function deserializeURLParam(a: string): Sequence {\n  let unescaped = a;\n  unescaped = unescaped.replace(/-/g, \"'\").replace(/&#45;/g, \"-\");\n  unescaped = unescaped.replace(/\\+/g, \" \").replace(/&#2b;/g, \"+\"); // Recognize + as space. Many URL encodings will do this.\n  unescaped = unescaped.replace(/_/g, \" \").replace(/&#95;/g, \"_\");\n  return parse(unescaped);\n}\n\n// Returns an empty sequence if the parameter is not present.\n// Throws an error if an alg is present but not valid.\nexport function getAlgURLParam(name: string): Sequence {\n  const s = new URLSearchParams(window.location.search).get(name) || \"\";\n  return deserializeURLParam(s);\n}\n\nexport interface AlgCubingNetOptions {\n  alg?: Sequence;\n  setup?: Sequence;\n  title?: string;\n  puzzle?: \"1x1x1\" | \"2x2x2\" | \"3x3x3\" | \"4x4x4\" | \"5x5x5\" | \"6x6x6\" | \"7x7x7\" | \"8x8x8\" | \"9x9x9\" | \"10x10x10\" | \"11x11x11\" | \"12x12x12\" | \"13x13x13\" | \"14x14x14\" | \"16x16x16\" | \"17x17x17\";\n  stage?: \"full\" | \"cross\" | \"F2L\" | \"LL\" | \"OLL\" | \"PLL\" | \"CLS\" | \"ELS\" | \"L6E\" | \"CMLL\" | \"WV\" | \"ZBLL\" | \"void\";\n  view?: \"editor\" | \"playback\" | \"fullscreen\";\n  type?: \"moves\" | \"reconstruction\" | \"alg\" | \"reconstruction-end-with-setup\";\n}\n\n// TODO: runtime validation?\nexport function algCubingNetLink(options: AlgCubingNetOptions): string {\n  const url = new URL(\"https://alg.cubing.net\");\n  if (!options.alg) {\n    throw new Error((\"An alg parameter is required.\"));\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if ([\"1x1x1\", \"2x2x2\", \"3x3x3\", \"4x4x4\", \"5x5x5\", \"6x6x6\", \"7x7x7\", \"8x8x8\", \"9x9x9\", \"10x10x10\", \"11x11x11\", \"12x12x12\", \"13x13x13\", \"14x14x14\", \"16x16x16\", \"17x17x17\"].indexOf(options.puzzle) === -1) {\n      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if ([\"full\", \"cross\", \"F2L\", \"LL\", \"OLL\", \"PLL\", \"CLS\", \"ELS\", \"L6E\", \"CMLL\", \"WV\", \"ZBLL\", \"void\"].indexOf(options.stage) === -1) {\n      throw new Error(`Invalid stage parameter: ${options.stage}`);\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if ([\"editor\", \"playback\", \"fullscreen\"].indexOf(options.view) === -1) {\n      throw new Error(`Invalid view parameter: ${options.view}`);\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if ([\"moves\", \"reconstruction\", \"alg\", \"reconstruction-end-with-setup\"].indexOf(options.type) === -1) {\n      throw new Error(`Invalid type parameter: ${options.type}`);\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n"],"names":["currentReportingLevel","numWarned","reportTypeMismatch","msg","Error","console","warn","setAlgPartTypeMismatchReportingLevel","level","AlgPart","matchesAlgType","a","t","type","assertMatchesType","isUnit","assertIsUnit","Unit","Move","Annotation","Container","Sequence","[object Object]","nestedUnits","super","this","n","Object","freeze","Group","nestedSequence","amount","Commutator","A","B","Conjugate","Pause","NewLine","Comment","comment","BlockMove","outerLayer","innerLayer","family","BareBlockMove","undefined","LayerBlockMove","RangeBlockMove","modifiedBlockMove","original","modifications","experimentalAppendBlockMove","s","newMove","coalesceLastMove","mod","oldNestedUnits","oldLastMove","length","m2","m1","newNestedUnits","slice","newAmount","push","experimentalConcatAlgs","args","Array","prototype","concat","apply","map","dispatch","algPart","dataDown","traverseSequence","traverseGroup","traverseBlockMove","traverseCommutator","traverseConjugate","traversePause","traverseNewLine","traverseComment","TraversalDownUp","traverse","TraversalUp","repetitionSuffix","absAmount","Math","abs","String","blockMoveToString","blockMove","out","invertInstance","Invert","sequence","reverse","traverseIntoUnit","group","commutator","conjugate","pause","newLine","expandInstance","Expand","flattenSequenceOneLevel","repeat","expandedA","expandedB","once","invert","algList","flattened","part","accordingTo","repeated","i","structureEqualsInstance","StructureEquals","dataDownSeq","coalesceBaseMovesInstance","CoalesceBaseMoves","coalesced","last","sameBlock","pop","moveA","moveB","algToStringInstance","ToString","output","spaceBetween","u1","u2","bind","expand","structureEquals","coalesceBaseMoves","algToString","algPartToStringForTesting","experimentalBlockMoveQuantumName","move","Example","fromJSON","json","j","unitFromJSON","ValidationError","ValidatorTraversal","validateFamily","allowedFamilyLists","list","plainMoveFamilies","x","y","z","M","E","S","m","e","singleSliceMoveFamilies","U","L","F","R","D","wideMoveFamilies","u","l","f","r","b","d","Uw","Lw","Fw","Rw","Bw","Dw","BaseMoveValidator","unit","BlockMoveValidatorInstance","BlockMoveValidator","validateSiGNMoves","flatAlgValidatorInstance","FlatAlgValidator","validateFlatAlg","validateSiGNAlg","parse","parser","options","validators","algo","pegParse","validate","cubeKeyMapping","73","75","87","79","83","76","68","69","74","70","72","71","78","86","67","82","85","77","84","89","66","186","59","65","80","81","190","keyToMove","altKey","ctrlKey","keyCode","serializeURLParam","escaped","replace","deserializeURLParam","unescaped","getAlgURLParam","name","URLSearchParams","window","location","search","get","algCubingNetLink","url","URL","alg","searchParams","set","setup","title","puzzle","indexOf","stage","view","toString"],"mappings":"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"}