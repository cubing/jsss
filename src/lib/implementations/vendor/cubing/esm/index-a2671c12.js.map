{"version":3,"file":"index-a2671c12.js","sources":["../../src/puzzle-geometry/Perm.ts","../../src/puzzle-geometry/PermOriSet.ts","../../src/puzzle-geometry/Quat.ts","../../src/puzzle-geometry/PlatonicGenerator.ts","../../src/puzzle-geometry/Puzzles.ts","../../src/puzzle-geometry/PuzzleGeometry.ts","../../src/puzzle-geometry/SchreierSims.ts"],"sourcesContent":["export function zeros(n: number): number[] {\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = 0;\n  }\n  return c;\n}\n\nexport function iota(n: number): number[] {\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  return c;\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm { // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): number {\n  let r = 1;\n  while (a > 1) {\n    r *= a;\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return a / gcd(a, b) * b;\n}\n\nexport class Perm {\n  public n: number;        // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n  public toString(): string { // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n  public mul(p2: Perm): Perm { // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n  public rmul(p2: Perm): Perm { // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n  public compareTo(p2: Perm): number { // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\nimport { factorial, iota, lcm, Perm, zeros } from \"./Perm\";\nexport class OrbitDef {\n  constructor(public size: number, public mod: number) { }\n  public reassemblySize(): number {\n    return factorial(this.size) * Math.pow(this.mod, this.size);\n  }\n}\nexport class OrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    public orbitdefs: OrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: Transformation[]) { }\n  public toKsolve(name: string, forTwisty: boolean): string[] {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\"Set \" + this.orbitnames[i] + \" \" +\n        this.orbitdefs[i].size + \" \" + this.orbitdefs[i].mod);\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(this.orbitnames[i]);\n      const o = this.solved.orbits[i].toKsolveVS();\n      result.push(o[0]);\n      result.push(o[1]);\n    }\n    result.push(\"End\");\n    result.push(\"\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"Move \" + this.movenames[i]);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (!forTwisty && this.moveops[i].orbits[j].isIdentity()) {\n          continue;\n        }\n        result.push(this.orbitnames[j]);\n        const o = this.moveops[i].orbits[j].toKsolve();\n        result.push(o[0]);\n        result.push(o[1]);\n      }\n      result.push(\"End\");\n      result.push(\"\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n  public toKpuzzle(): object {\n    const orbits: { [orbitName: string]: any } = {} ;\n    const start: { [orbitName: string]: any } = {} ;\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = { numPieces: this.orbitdefs[i].size,\n                        orientations: this.orbitdefs[i].mod } ;\n      start[this.orbitnames[i]] = this.solved.orbits[i].toKpuzzle() ;\n    }\n    const moves: { [moveName: string]: any } = {} ;\n    for (let i = 0; i < this.movenames.length; i++) {\n      const mp: { [orbitName: string]: any } = {} ;\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        mp[this.orbitnames[j]] = this.moveops[i].orbits[j].toKpuzzle() ;\n      }\n      moves[this.movenames[i]] = mp ;\n    }\n    return { orbits, startPieces: start, moves } ;\n  }\n  public optimize(): OrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: OrbitDef[] = [];\n    const newsolved: Orbit[] = [];\n    const newmoveops: Orbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0) {\n            changed[k] = true;\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0) {\n              for (let o = 0; o < om; o++) {\n                duo.union(k * om + o, this.moveops[j].orbits[i].perm[k] * om +\n                  (o + this.moveops[j].orbits[i].ori[k]) % om);\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (this.solved.orbits[i].perm[j] ===\n              this.solved.orbits[i].perm[k]) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(this.orbitnames[i] + \"_p\" + j);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new OrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new OrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].\n              remap(no, on, nv).killOri());\n          }\n        }\n      }\n    }\n    return new OrbitsDef(neworbitnames, neworbitdefs,\n      new VisibleState(newsolved), this.movenames,\n      newmoveops.map((_) => new Transformation(_)));\n  }\n  // generate a new \"solved\" position based on scrambling\n  // we use an algorithm that should be faster for large puzzles than\n  // just picking random moves.\n  public scramble(n: number): void {\n    const pool: Transformation[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) { // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    this.solved = this.solved.mul(s);\n  }\n  public reassemblySize(): number {\n    let n = 1;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\nexport class Orbit {\n  public static e(n: number, mod: number): Orbit {\n    return new Orbit(iota(n), zeros(n), mod);\n  }\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number) { }\n  public mul(b: Orbit): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[i] = this.perm[b.perm[i]];\n      newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public inv(): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public equal(b: Orbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + (this.ori[i] + j) % o;\n      }\n    }\n    return new Perm(newPerm);\n  }\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n  public order(): number { // can be made more efficient\n    return this.toPerm().order();\n  }\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public remap(no: number[], on: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public remapVS(no: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n  public toKsolveVS(): string[] {\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), this.ori.join(\" \")];\n  }\n  public toKsolve(): string[] {\n    const newori = new Array<number>(this.ori.length);\n    for (let i = 0; i < newori.length; i++) {\n      newori[this.perm[i]] = this.ori[i];\n    }\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), newori.join(\" \")];\n  }\n  public toKpuzzle(): object {\n    return { permutation: this.perm, orientation: this.ori } ;\n  }\n}\nexport class TransformationBase {\n  constructor(public orbits: Orbit[]) { }\n  public internalMul(b: TransformationBase): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n  public internalInv(): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].inv());\n    }\n    return newOrbits;\n  }\n  public equal(b: TransformationBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public killOri(): this {\n    for (let i = 0; i < this.orbits.length; i++) {\n      this.orbits[i].killOri();\n    }\n    return this;\n  }\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = this.orbits[i].toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = perms[i];\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const o = this.orbits[i].orimod;\n      const s = this.orbits[i].identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * this.orbits[i].perm.length;\n    }\n    return r;\n  }\n  public order(): number {\n    let r = 1;\n    for (let i = 0; i < this.orbits.length; i++) {\n      r = lcm(r, this.orbits[i].order());\n    }\n    return r;\n  }\n}\nexport class Transformation extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n  public mul(b: Transformation): Transformation {\n    return new Transformation(this.internalMul(b));\n  }\n  public mulScalar(n: number): Transformation {\n    if (n === 0) {\n      return this.e();\n    }\n    let t: Transformation = this;\n    if (n < 0) {\n      t = t.inv();\n      n = - n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n  public inv(): Transformation {\n    return new Transformation(this.internalInv());\n  }\n  public e(): Transformation {\n    return new Transformation(this.orbits.map(\n      (_: Orbit) => Orbit.e(_.perm.length, _.orimod)));\n  }\n}\nexport class VisibleState extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n  public mul(b: Transformation): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  public heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"\" + 0 + \": canonseq \" + 1);\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || ((commutes[mv] & (1 << st)) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function expandfaces(rots: Quat[], faces: Quat[][]): Quat[][] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (let i = 0; i < rots.length; i++) {\n    for (let k = 0; k < faces.length; k++) {\n      const face = faces[k];\n      const nface = [];\n      for (let j = 0; j < face.length; j++) {\n        nface.push(face[j].rotateplane(rots[i]));\n      }\n      nfaces.push(nface);\n    }\n  }\n  return nfaces;\n}\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function random(): Quat { // generate a random quat\n  const q = new Quat(Math.random() * 2 - 1, Math.random() * 2 - 1,\n    Math.random() * 2 - 1, Math.random() * 2 - 1);\n  return q.smul(1 / q.len());\n}\n\nexport function solvethreeplanes(p1: number, p2: number, p3: number, planes: Quat[]): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if ((planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(public a: number, public b: number, public c: number, public d: number) {\n  }\n  public mul(q: Quat): Quat { // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a);\n  }\n  public toString(): string {\n    return \"Q[\" + this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d + \"]\";\n  }\n  public dist(q: Quat): number { // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  public len(): number { // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n  public cross(q: Quat): Quat { // cross product\n    return new Quat(0, this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d, this.b * q.c - this.c * q.b);\n  }\n  public dot(q: Quat): number { // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n  public normalize(): Quat { // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  public makenormal(): Quat { // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n  public normalizeplane(): Quat { // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n  public smul(m: number): Quat { // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n  public sum(q: Quat): Quat { // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n  public sub(q: Quat): Quat { // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n  public angle(): number { // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n  public invrot(): Quat { // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n  public det3x3(\n    a00: number, a01: number, a02: number,\n    a10: number, a11: number, a12: number,\n    a20: number, a21: number, a22: number): number {\n    // 3x3 determinant\n    return a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20);\n  }\n  public rotateplane(q: Quat): Quat { // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n  public rotatepoint(q: Quat): Quat { // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n  public rotateface(face: Quat[]): Quat[] { // rotate a face by this Q.\n    const that = this;\n    return face.map((_: Quat) => _.rotatepoint(that));\n  }\n  public rotatecubie(cubie: Quat[][]): Quat[][] { // rotate a cubie by this Q.\n    const that = this;\n    return cubie.map((_: Quat[]) => that.rotateface(_));\n  }\n  public intersect3(p2: Quat, p3: Quat): Quat | false { // intersect three planes if there is one\n    const det = this.det3x3(this.b, this.c, this.d,\n      p2.b, p2.c, p2.d,\n      p3.b, p3.c, p3.d);\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(0,\n      this.det3x3(this.a, this.c, this.d,\n        p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) / det,\n      this.det3x3(this.b, this.a, this.d,\n        p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) / det,\n      this.det3x3(this.b, this.c, this.a,\n        p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) / det);\n  }\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const that = this; // welcome to Javascript\n    const d = this.a;\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const inout = face.map((_: Quat) => that.side(_.dot(that) - d));\n      let seen = 0;\n      for (let i = 0; i < inout.length; i++) {\n        seen |= 1 << (inout[i] + 1);\n      }\n      if ((seen & 5) === 5) { // saw both sides\n        for (let s = -1; s <= 1; s += 2) {\n          const nface = [];\n          for (let k = 0; k < face.length; k++) {\n            if (inout[k] === s || inout[k] === 0) {\n              nface.push(face[k]);\n            }\n            const kk = (k + 1) % face.length;\n            if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n              const vk = face[k].dot(this) - d;\n              const vkk = face[kk].dot(this) - d;\n              const r = vk / (vk - vkk);\n              const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n              nface.push(pt);\n            }\n          }\n          nfaces.push(nface);\n        }\n      } else { // no split\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n  public faceside(face: Quat[]): number { // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n  public sameplane(p: Quat): boolean { // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n  public makecut(r: number): Quat { // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = 2 * Math.PI / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n  new Quat(0.5, 0.5, 0.5, 0.5)];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = 2 * Math.PI / 6;\n  return [new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0)];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps ||\n          negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  while (true) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","export type PuzzleDescriptionString = string;\n\nexport const Puzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\": \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\": \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\": \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\": \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\": \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"pentultimate\": \"d f 0\",\n  \"starminx\": \"d v 0.93796236956\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.93796236956\",\n};\n\nexport type PuzzleName = keyof typeof Puzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n/* tslint:disable only-arrow-functions */ // TODO\n/* tslint:disable typedef */ // TODO\n\nimport { Perm } from \"./Perm\";\nimport { Orbit, OrbitDef, OrbitsDef, showcanon, Transformation, VisibleState } from \"./PermOriSet\";\nimport { closure, cube, dodecahedron, getface, icosahedron, octahedron, tetrahedron, uniqueplanes } from \"./PlatonicGenerator\";\nimport { PuzzleDescriptionString, Puzzles } from \"./Puzzles\";\nimport { centermassface, expandfaces, Quat } from \"./Quat\";\n\nexport interface StickerDatSticker {\n  coords: number[][];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n}\n\nexport interface StickerDatFace {\n  coords: number[][];\n  name: string;\n}\n\nexport type StickerDatAxis = [number[], string, number];\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\nconst defaultnets: any = {\n  4: // four faces: tetrahedron\n    [\n      [\"F\", \"D\", \"L\", \"R\"],\n    ],\n  6: // six faces: cube\n    [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n  8: // eight faces: octahedron\n    [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n  12: // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n  20: // twenty faces: icosahedron\n    [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n};\n\nconst defaultcolors: any = {\n  // the colors should use the same naming convention as the nets, above.\n  4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n  6: {\n    U: \"#ffffff\", F: \"#00ff00\", R: \"#ff0000\",\n    D: \"#ffff00\", B: \"#0000ff\", L: \"#ff8000\",\n  },\n  8: {\n    U: \"#e085b9\", F: \"#080d99\", R: \"#c1e35c\", D: \"#22955e\",\n    BB: \"#9121ab\", L: \"#b27814\", BL: \"#0d35ad\", BR: \"#eb126b\",\n  },\n  12: {\n    U: \"#ffffff\", F: \"#006633\", R: \"#ff0000\", C: \"#ffffd0\",\n    A: \"#3399ff\", L: \"#660099\", E: \"#ff66cc\", BF: \"#99ff00\",\n    BR: \"#0000ff\", BL: \"#ffff00\", I: \"#ff6633\", D: \"#999999\",\n  },\n  20: {\n    R: \"#db69f0\", C: \"#178fde\", F: \"#23238b\", E: \"#9cc726\",\n    L: \"#2c212d\", U: \"#177fa7\", A: \"#e0de7f\", G: \"#2b57c0\",\n    I: \"#41126b\", S: \"#4b8c28\", H: \"#7c098d\", J: \"#7fe7b4\",\n    B: \"#85fb74\", K: \"#3f4bc3\", D: \"#0ff555\", M: \"#f1c2c8\",\n    O: \"#58d340\", P: \"#c514f2\", N: \"#14494e\", Q: \"#8b1be1\",\n  },\n};\n\n// the default precedence of the faces is given here.  This permits\n// the orientations to be reasonably predictable.  There are tradeoffs;\n// some face precedence orders do better things to the edge orientations\n// than the corner orientations and some are the opposite.\nconst defaultfaceorders: any = {\n  4: [\"F\", \"D\", \"L\", \"R\"],\n  6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n  8: [\"F\", \"BB\", \"D\", \"U\", \"BR\", \"L\", \"R\", \"BL\"],\n  12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\",\n    \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n  20: [\"L\", \"S\", \"E\", \"O\", \"F\", \"B\", \"I\", \"P\", \"R\", \"K\",\n    \"U\", \"D\", \"J\", \"A\", \"Q\", \"H\", \"G\", \"N\", \"M\", \"C\"],\n};\n\nfunction findelement(a: any[], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getpuzzles(): { [s: string]: PuzzleDescriptionString } {\n  // get some simple definitions of basic puzzles\n  return Puzzles;\n}\n\nexport function getpuzzle(puzzleName: PuzzleName): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return Puzzles[puzzleName];\n}\n\nexport function parsedesc(s: string): any { // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return false;\n  }\n  if (a[0] !== \"o\" && a[0] !== \"c\" && a[0] !== \"i\" && a[0] !== \"d\" && a[0] !== \"t\") {\n    return false;\n  }\n  const r = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return false;\n    }\n    r.push([a[i], a[i + 1]]);\n  }\n  return [a[0], r];\n}\n\n// TODO: Automatically associate this with the source list.\ntype PuzzleName = \"2x2x2\" | \"3x3x3\" | \"4x4x4\" | \"5x5x5\" | \"6x6x6\" | \"7x7x7\" | \"8x8x8\" | \"9x9x9\" | \"10x10x10\" | \"11x11x11\" | \"12x12x12\" | \"13x13x13\" | \"20x20x20\" | \"skewb\" | \"master skewb\" | \"professor skewb\" | \"compy cube\" | \"helicopter\" | \"dino\" | \"little chop\" | \"pyramorphix\" | \"mastermorphix\" | \"pyraminx\" | \"master pyraminx\" | \"professor pyraminx\" | \"Jing pyraminx\" | \"master pyramorphix\" | \"megaminx\" | \"gigaminx\" | \"pentultimate\" | \"starminx\" | \"starminx 2\" | \"pyraminx crystal\" | \"chopasaurus\" | \"big chop\" | \"skewb diamond\" | \"FTO\" | \"Christopher's jewel\" | \"octastar\" | \"Trajber's octahedron\" | \"radio chop\" | \"icosamate\" | \"icosahedron 2\" | \"icosahedron 3\" | \"icosahedron static faces\" | \"icosahedron moving faces\" | \"Eita\";\n\nexport function getPuzzleGeometryByDesc(desc: string, options: string[] = []): PuzzleGeometry {\n  const [shape, cuts] = parsedesc(desc);\n  const pg = new PuzzleGeometry(shape, cuts, [\"allmoves\", \"true\"].concat(options));\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(puzzleName: PuzzleName, options: string[] = []): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(Puzzles[puzzleName], options);\n}\n\nfunction getmovename(geo: any, bits: number, slices: number): any {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let nbits = 0;\n  let inverted = false;\n  for (let i = 0; i <= slices; i++) {\n    if ((bits >> i) & 1) {\n      nbits |= 1 << (slices - i);\n    }\n  }\n  if (nbits < bits) { // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = nbits;\n    inverted = true;\n  }\n  let movenameFamily = geo[0];\n  let movenamePrefix = \"\";\n  let hibit = 0;\n  while (bits >> (1 + hibit)) {\n    hibit++;\n  }\n  if (bits === (2 << slices) - 1) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits === (1 << hibit)) {\n    if (hibit > 0) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else if (bits === ((2 << hibit) - 1)) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (hibit > 1) {\n      movenamePrefix = String(hibit + 1);\n    }\n  } else {\n    movenamePrefix = \"_\" + bits + \"_\";\n    //       throw \"We only support slice and outer block moves right now. \" + bits ;\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  The facenames must\n// be prefix-free.\nfunction splitByFaceNames(s: string, facenames: any[]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    let found = false;\n    for (let i = 0; i < facenames.length; i++) {\n      if (s.substr(at).startsWith(facenames[i][1])) {\n        r.push(facenames[i][1]);\n        at += facenames[i][1].length;\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      throw new Error((\"Could not split \" + s + \" into face names.\"));\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [- q.b / maxdist, - q.c / maxdist, - q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Quat[], maxdist: number): number[][] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    r[n - i - 1] = toCoords(q[i], maxdist);\n  }\n  return r;\n}\n\nfunction trimEdges(face: Quat[], tr: number): Quat[] {\n  const r: Quat[] = [];\n  for (let iter = 1; iter < 10; iter++) {\n    for (let i = 0; i < face.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      const A = face[pi].sub(face[i]).normalize();\n      const B = face[ni].sub(face[i]).normalize();\n      const d = A.dot(B);\n      const m = tr / Math.sqrt(1 - d * d);\n      r[i] = face[i].sum(A.sum(B).smul(m));\n    }\n    let good = true;\n    for (let i = 0; good && i < r.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      if (r[pi].sub(r[i]).cross(r[ni].sub(r[i])).dot(r[i]) >= 0) {\n        good = false;\n      }\n    }\n    if (good) {\n      return r;\n    }\n    tr /= 2;\n  }\n  return face;\n}\n\nexport class PuzzleGeometry {\n  public args: string = \"\";\n  public rotations: Quat[];    // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  public baseplanes: Quat[];   // planes, corresponding to faces\n  public facenames: any[];     // face names\n  public faceplanes: any;      // face planes\n  public edgenames: any[];     // edge names\n  public vertexnames: any[];   // vertexnames\n  public geonormals: any[];    // all geometric directions, with names and types\n  public moveplanes: Quat[];   // the planes that split moves\n  public moveplanesets: any[]; // the move planes, in parallel sets\n  public movesetorders: any[]; // the order of rotations for each move set\n  public movesetgeos: any[];   // geometric feature information for move sets\n  public basefaces: Quat[][];  // polytope faces before cuts\n  public faces: Quat[][];      // all the stickers\n  public basefacecount: number;      // number of base faces\n  public stickersperface: number;    // number of stickers per face\n  public cornerfaces: number;        // number of faces that meet at a corner\n  public cubies: any[];        // the cubies\n  public shortedge: number;         // shortest edge\n  public vertexdistance: number;    // vertex distance\n  public edgedistance: number;      // edge distance\n  public orbits: number;            // count of cubie orbits\n  public facetocubies: any[];  // map a face to a cubie index and offset\n  public moverotations: Quat[][]; // move rotations\n  public cubiekey: any;             // cubie locator\n  public cubiekeys: string[];  // cubie keys\n  public facelisthash: any;         // face list by key\n  public cubiesetnames: any[]; // cubie set names\n  public cubieords: number[];  // the size of each orbit\n  public cubiesetnums: number[];\n  public cubieordnums: number[];\n  public orbitoris: number[];  // the orientation size of each orbit\n  public cubievaluemap: number[]; // the map for identical cubies\n  public cubiesetcubies: number[][]; // cubies in each cubie set\n  public movesbyslice: any[];  // move as perms by slice\n  public cmovesbyslice: any[] = []; // cmoves as perms by slice\n  // options\n  public verbose: number = 0;         // verbosity (console.log)\n  public allmoves: boolean = false; // generate all slice moves in ksolve\n  public outerblockmoves: boolean;  // generate outer block moves\n  public vertexmoves: boolean;      // generate vertex moves\n  public addrotations: boolean;     // add symmetry information to ksolve output\n  public movelist: any;             // move list to generate\n  public parsedmovelist: any;       // parsed move list\n  public cornersets: boolean = true; // include corner sets\n  public centersets: boolean = true; // include center sets\n  public edgesets: boolean = true;   // include edge sets\n  public graycorners: boolean = false; // make corner sets gray\n  public graycenters: boolean = false; // make center sets gray\n  public grayedges: boolean = false;   // make edge sets gray\n  public killorientation: boolean = false; // eliminate any orientations\n  public optimize: boolean = false;  // optimize PermOri\n  public scramble: number = 0;       // scramble?\n  public ksolvemovenames: string[]; // move names from ksolve\n  public fixPiece: string = \"\";      // fix a piece?\n  public orientCenters: boolean = false; // orient centers?\n  public duplicatedFaces: number[] = []; // which faces are duplicated\n  public duplicatedCubies: number[] = []; // which cubies are duplicated\n  public fixedCubie: number = -1;    // fixed cubie, if any\n  public svggrips: any[];       // grips from svg generation by svg coordinate\n  public net: any = [];\n  public colors: any = [];\n  public faceorder: any = [];\n  public faceprecedence: number[] = [];\n  constructor(shape: string, cuts: string[][], optionlist: any[] | undefined) {\n    if (optionlist !== undefined) {\n      if (optionlist.length % 2 !== 0) {\n        throw new Error(\"Odd length in option list?\");\n      }\n      for (let i = 0; i < optionlist.length; i += 2) {\n        if (optionlist[i] === \"verbose\") {\n          this.verbose++;\n        } else if (optionlist[i] === \"quiet\") {\n          this.verbose = 0;\n        } else if (optionlist[i] === \"allmoves\") {\n          this.allmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"outerblockmoves\") {\n          this.outerblockmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"vertexmoves\") {\n          this.vertexmoves = optionlist[i + 1];\n        } else if (optionlist[i] === \"rotations\") {\n          this.addrotations = optionlist[i + 1];\n        } else if (optionlist[i] === \"cornersets\") {\n          this.cornersets = optionlist[i + 1];\n        } else if (optionlist[i] === \"centersets\") {\n          this.centersets = optionlist[i + 1];\n        } else if (optionlist[i] === \"edgesets\") {\n          this.edgesets = optionlist[i + 1];\n        } else if (optionlist[i] === \"graycorners\") {\n          this.graycorners = optionlist[i + 1];\n        } else if (optionlist[i] === \"graycenters\") {\n          this.graycenters = optionlist[i + 1];\n        } else if (optionlist[i] === \"grayedges\") {\n          this.grayedges = optionlist[i + 1];\n        } else if (optionlist[i] === \"movelist\") {\n          this.movelist = optionlist[i + 1];\n        } else if (optionlist[i] === \"killorientation\") {\n          this.killorientation = optionlist[i + 1];\n        } else if (optionlist[i] === \"optimize\") {\n          this.optimize = optionlist[i + 1];\n        } else if (optionlist[i] === \"scramble\") {\n          this.scramble = optionlist[i + 1];\n        } else if (optionlist[i] === \"fix\") {\n          this.fixPiece = optionlist[i + 1];\n        } else if (optionlist[i] === \"orientcenters\") {\n          this.orientCenters = optionlist[i + 1];\n        } else {\n          throw new Error(\"Bad option while processing option list \" + optionlist[i]);\n        }\n      }\n    }\n    this.args = shape + \" \" + (cuts.map((_) => _.join(\" \")).join(\" \"));\n    if (optionlist) {\n      this.args += \" \" + optionlist.join(\" \");\n    }\n    if (this.verbose > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(shape, cuts);\n  }\n\n  public create(shape: string, cuts: any[]): void {\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    // var that = this ; // TODO\n    this.moveplanes = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\": g = cube(); break;\n      case \"o\": g = octahedron(); break;\n      case \"i\": g = icosahedron(); break;\n      case \"t\": g = tetrahedron(); break;\n      case \"d\": g = dodecahedron(); break;\n      default: throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.verbose) { console.log(\"# Rotations: \" + this.rotations.length); }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.basefacecount = baseplanes.length;\n    const net = defaultnets[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors[baseplanes.length];\n    this.faceorder = defaultfaceorders[baseplanes.length];\n    if (this.verbose) { console.log(\"# Base planes: \" + baseplanes.length); }\n    const baseface = getface(baseplanes);\n    if (this.verbose) { console.log(\"# Face vertices: \" + baseface.length); }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const cutplanes = [];\n    for (let i = 0; i < cuts.length; i++) {\n      let normal = null;\n      switch (cuts[i][0]) {\n        case \"f\": normal = facenormal; break;\n        case \"v\": normal = vertexnormal; break;\n        case \"e\": normal = edgenormal; break;\n        default: throw new Error(\"Bad cut argument: \" + cuts[i][0]);\n      }\n      cutplanes.push(normal.makecut(cuts[i][1]));\n    }\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.verbose) { console.log(\"# Boundary is \" + boundary); }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    let faces = [getface(planes)];\n    this.basefaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      this.basefaces.push(face);\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n where\n    //   n planes meet at a vertex.  We arbitrarily choose the one that is\n    //   alphabetically first (and we will probably want to change this).\n    //\n    const facenames: any[] = [];\n    const faceplanes = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = faces[0].length;\n    function searchaddelement(a: any[], p: Quat, name: any) {\n      for (let i = 0; i < a.length; i++) {\n        if (a[i][0].dist(p) < eps) {\n          a[i].push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: any = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === net[i][1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < net[i].length; j++) {\n        if (net[i][j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== net[i][j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = net[i][j];\n        facenametoindex[net[i][j]] = of;\n      }\n    }\n    for (let i = 0; i < faceindextoname.length; i++) {\n      let found = false;\n      for (let j = 0; j < this.faceorder.length; j++) {\n        if (faceindextoname[i] === this.faceorder[j]) {\n          this.faceprecedence[i] = j;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error(\"Could not find face \" + faceindextoname[i] +\n          \" in face order list \" + this.faceorder);\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    // fix the edge names; use face precedence order\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      let c1 = faceindextoname[edgenames[i][1]];\n      const c2 = faceindextoname[edgenames[i][2]];\n      if (this.faceprecedence[edgenames[i][1]] <\n        this.faceprecedence[edgenames[i][2]]) {\n        c1 = c1 + c2;\n      } else {\n        c1 = c2 + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; clockwise rotations; low face first.\n    this.cornerfaces = vertexnames[0].length - 1;\n    for (let i = 0; i < vertexnames.length; i++) {\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      let st = 1;\n      for (let j = 2; j < vertexnames[i].length; j++) {\n        if (this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n          this.faceprecedence[facenametoindex[vertexnames[i][st][0]]]) {\n          st = j;\n        }\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        r = r + vertexnames[i][st][0];\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][2] === vertexnames[i][k][1]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    if (this.verbose > 1) {\n      console.log(\"Face precedence list: \" + this.faceorder.join(\" \"));\n      console.log(\"Face names: \" + facenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"Edge names: \" + edgenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"Vertex names: \" + vertexnames.map((_: any) => _[1]).join(\" \"));\n    }\n    const geonormals = [];\n    for (let i = 0; i < faceplanes.length; i++) {\n      geonormals.push(\n        [faceplanes[i][0].makenormal(), faceplanes[i][1], \"f\"]);\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      geonormals.push([edgenames[i][0].makenormal(), edgenames[i][1], \"e\"]);\n    }\n    for (let i = 0; i < vertexnames.length; i++) {\n      geonormals.push(\n        [vertexnames[i][0].makenormal(), vertexnames[i][1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const zero = new Quat(0, 0, 0, 0);\n    this.edgedistance = faces[0][0].sum(faces[0][1]).smul(0.5).dist(zero);\n    this.vertexdistance = faces[0][0].dist(zero);\n    if (this.verbose) {\n      console.log(\"# Distances: face \" + 1 + \" edge \" + this.edgedistance +\n        \" vertex \" + this.vertexdistance);\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (let i = 0; i < this.rotations.length; i++) {\n        const q = cutplanes[c].rotateplane(this.rotations[i]);\n        let wasseen = false;\n        for (let j = 0; j < this.moveplanes.length; j++) {\n          if (q.sameplane(this.moveplanes[j])) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          faces = q.cutfaces(faces);\n        }\n      }\n    }\n    this.faces = faces;\n    if (this.verbose) { console.log(\"# Faces is now \" + faces.length); }\n    this.stickersperface = faces.length;\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    let shortedge = 1e99;\n    for (let i = 0; i < faces.length; i++) {\n      for (let j = 0; j < faces[i].length; j++) {\n        const k = (j + 1) % faces[i].length;\n        const t = faces[i][j].dist(faces[i][k]);\n        if (t < shortedge) {\n          shortedge = t;\n        }\n      }\n    }\n    this.shortedge = shortedge;\n    if (this.verbose) { console.log(\"# Short edge is \" + shortedge); }\n  }\n\n  public keyface(face: Quat[]): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    for (let i = 0; i < this.moveplanesets.length; i++) {\n      let t = 0;\n      for (let j = 0; j < this.moveplanesets[i].length; j++) {\n        if (this.moveplanesets[i][j].faceside(face) > 0) {\n          t++;\n        }\n      }\n      s = s + \" \" + t;\n    }\n    return s;\n  }\n\n  public findcubie(face: Quat[]): number {\n    return this.facetocubies[this.findface(face)][0];\n  }\n\n  public findface(face: Quat[]): number {\n    const cm = centermassface(face);\n    const key = this.keyface(face);\n    for (let i = 0; i < this.facelisthash[key].length; i++) {\n      const face2 = this.facelisthash[key][i];\n      if (Math.abs(cm.dist(\n        centermassface(this.faces[face2]))) < eps) {\n        return face2;\n      }\n    }\n    throw new Error(\"Could not find face.\");\n  }\n\n  public project2d(facen: number, edgen: number, targvec: Quat[]): any {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(0, targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]), 0);\n    return [x1, y1, off];\n  }\n\npublic allstickers(): void {\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.verbose) { console.log(\"# Total stickers is now \" + this.faces.length); }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets = [];\n    for (let i = 0; i < this.moveplanes.length; i++) {\n      let wasseen = false;\n      const q = this.moveplanes[i];\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanesets[j][0].makenormal())) {\n          moveplanesets[j].push(q);\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        moveplanesets.push([q]);\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = q[0].makenormal();\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.verbose) { console.log(\"# Move plane sets: \" + sizes); }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (let i = 0; i < this.rotations.length; i++) {\n      const q: Quat = this.rotations[i];\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanesets[j][0].makenormal())) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanesets[i][0]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanesets[i][0].makenormal();\n      let neg = null;\n      let pos = null;\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const d = p0.dot(this.geonormals[j][0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [this.geonormals[j][1], this.geonormals[j][2]];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [this.geonormals[j][1], this.geonormals[j][2]];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([pos[0], pos[1], neg[0], neg[1],\n      1 + moveplanesets[i].length]);\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const cubiehash: any = {};\n    const facelisthash: any = {};\n    const cubiekey: any = {};\n    const cubiekeys = [];\n    const cubies: Quat[][][] = [];\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!cubiehash[s]) {\n        cubiekey[s] = cubies.length;\n        cubiekeys.push(s);\n        cubiehash[s] = [];\n        facelisthash[s] = [];\n        cubies.push(cubiehash[s]);\n      }\n      facelisthash[s].push(i);\n      cubiehash[s].push(face);\n      //  If we find a core cubie, split it up into multiple cubies,\n      //  because ksolve doesn't handle orientations that are not\n      //  cyclic, and the rotation group of the core is not cyclic.\n      if (facelisthash[s].length === this.basefacecount) {\n        if (this.verbose) { console.log(\"# Splitting core.\"); }\n        for (let suff = 0; suff < this.basefacecount; suff++) {\n          const s2 = s + \" \" + suff;\n          facelisthash[s2] = [facelisthash[s][suff]];\n          cubiehash[s2] = [cubiehash[s][suff]];\n          cubiekeys.push(s2);\n          cubiekey[s2] = cubies.length;\n          cubies.push(cubiehash[s2]);\n        }\n        cubiehash[s] = [];\n        cubies[cubiekey[s]] = [];\n      }\n    }\n    this.cubiekey = cubiekey;\n    this.facelisthash = facelisthash;\n    this.cubiekeys = cubiekeys;\n    if (this.verbose) { console.log(\"# Cubies: \" + Object.keys(cubiehash).length); }\n    const that = this;\n    //  Sort the faces around each corner so they are clockwise.  Only\n    //  relevant for cubies that actually are corners (three or more\n    //  faces).  In general cubies might have many faces; for icosohedrons\n    //  there are five faces on the corner cubies.\n    this.cubies = cubies;\n    for (let k = 0; k < cubies.length; k++) {\n      const cubie = cubies[k];\n      if (cubie.length < 2) {\n        continue;\n      }\n      if (cubie.length === this.basefacecount) { // looks like core?  don't sort\n        continue;\n      }\n      if (cubie.length > 5) {\n        throw new Error(\"Bad math; too many faces on this cubie \" + cubie.length);\n      }\n      const s = this.keyface(cubie[0]);\n      const facelist = facelisthash[s];\n      const cm = cubie.map((_) => centermassface(_));\n      const cmall = centermassface(cm);\n      for (let looplimit = 0; cubie.length > 2; looplimit++) {\n        let changed = false;\n        for (let i = 0; i < cubie.length; i++) {\n          const j = (i + 1) % cubie.length;\n          // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n          if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n            const t = cubie[i];\n            cubie[i] = cubie[j];\n            cubie[j] = t;\n            const u = cm[i];\n            cm[i] = cm[j];\n            cm[j] = u;\n            const v = facelist[i];\n            facelist[i] = facelist[j];\n            facelist[j] = v;\n            changed = true;\n          }\n        }\n        if (!changed) {\n          break;\n        }\n        if (looplimit > 1000) {\n          throw new Error((\"Bad epsilon math; too close to border\"));\n        }\n      }\n      let mini = 0;\n      let minf = this.findface(cubie[mini]);\n      for (let i = 1; i < cubie.length; i++) {\n        const temp = this.findface(cubie[i]);\n        if (this.faceprecedence[this.getfaceindex(temp)] <\n          this.faceprecedence[this.getfaceindex(minf)]) {\n          mini = i;\n          minf = temp;\n        }\n      }\n      if (mini !== 0) {\n        const ocubie = cubie.slice();\n        const ofacelist = facelist.slice();\n        for (let i = 0; i < cubie.length; i++) {\n          cubie[i] = ocubie[(mini + i) % cubie.length];\n          facelist[i] = ofacelist[(mini + i) % cubie.length];\n        }\n      }\n    }\n    //  Build an array that takes each face to a cubie ordinal and a\n    //  face number.\n    const facetocubies = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const facelist = facelisthash[cubiekeys[i]];\n      for (let j = 0; j < facelist.length; j++) {\n        facetocubies[facelist[j]] = [i, j];\n      }\n    }\n    this.facetocubies = facetocubies;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTER\", \"EDGE\", \"CORNER\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    // var cubiesetnumhash = {} ; // TODO\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    function getcolorkey(cubienum: number): string {\n      return cubies[cubienum].map(\n        (_) => that.getfaceindex(that.findface(_))).join(\" \");\n    }\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      if (seen[i]) {\n        continue;\n      }\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.basefacecount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : (typectr + 1));\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        for (let j = 0; j < moverotations.length; j++) {\n          const tq = this.findcubie(moverotations[j][0].rotateface(cubies[cind][0]));\n          if (!seen[tq]) {\n            queue.push(tq);\n            seen[tq] = true;\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    this.orbits = cubieords.length;\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.fixPiece !== \"\") {\n      for (let i = 0; i < cubies.length; i++) {\n        if ((this.fixPiece === \"v\" && cubies[i].length > 2) ||\n          (this.fixPiece === \"e\" && cubies[i].length === 2) ||\n          (this.fixPiece === \"f\" && cubies[i].length === 1)) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\"Could not find a cubie of type \" + this.fixPiece + \" to fix.\");\n      }\n    }\n    // show the orbits\n    if (this.verbose) { console.log(\"# Cubie orbit sizes \" + cubieords); }\n  }\n\n  public spinmatch(a: string, b: string): boolean {\n    // are these the same rotationally?\n    if (a === b) {\n      return true;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    try {\n      const e1 = splitByFaceNames(a, this.facenames);\n      const e2 = splitByFaceNames(b, this.facenames);\n      if (e1.length !== e2.length) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        if (e1[i] === e2[0]) {\n          for (let j = 0; j < e2.length; j++) {\n            if (e1[(i + j) % e1.length] !== e2[j]) {\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public parsemove(mv: string): any { // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([A-Za-z]+)([-'0-9]+)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    let grip = p[4];\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (p[2] !== undefined || p[3] !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    let geo;\n    let msi = -1;\n    const upperCaseGrip = grip.toUpperCase();\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (this.spinmatch(g[0], upperCaseGrip)) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (this.spinmatch(g[2], upperCaseGrip)) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (upperCaseGrip !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + mv);\n    }\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      if (p[2] === undefined) {\n        hislice = parseInt(p[3], 10);\n        if (upperCaseGrip === grip) {\n          loslice = hislice;\n        } else {\n          loslice = 1;\n        }\n      } else {\n        hislice = parseInt(p[3], 10);\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (loslice < 0 || loslice > this.moveplanesets[msi].length ||\n      hislice < 0 || hislice > this.moveplanesets[msi].length) {\n      throw new Error(\"Bad slice spec \" + loslice + \" \" + hislice);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      if (amountstr[0] === \"+\") {\n        amountstr = amountstr.substring(1);\n      } else if (amountstr[0] === \"-\") {\n        if (amountstr === \"-\") {\n          amountstr = \"-1\";\n        }\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    const r = [mv, msi, loslice, hislice, firstgrip, amount];\n    return r;\n  }\n\n  public genperms(): void { // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) { // did this already?\n      return;\n    }\n    const movesbyslice = [];\n    const cmovesbyslice = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        const face = this.faces[i];\n        let t = 0;\n        for (let j = 0; j < moveplaneset.length; j++) {\n          if (moveplaneset[j].faceside(face) < 0) {\n            t++;\n          }\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axismoves = [];\n      const axiscmoves = [];\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        const slicemoves = [];\n        const slicecmoves = [];\n        const cubiedone = [];\n        for (let i = 0; i < this.faces.length; i++) {\n          if (slicenum[i] !== sc) {\n            continue;\n          }\n          const a = [i];\n          const b = this.facetocubies[i].slice();\n          let face = this.faces[i];\n          let fi2 = i;\n          while (true) {\n            slicenum[fi2] = -1;\n            const face2 = this.moverotations[k][0].rotateface(face);\n            fi2 = this.findface(face2);\n            if (slicenum[fi2] < 0) {\n              break;\n            }\n            if (slicenum[fi2] !== sc) {\n              throw new Error(\"Bad movement?\");\n            }\n            a.push(fi2);\n            const c = this.facetocubies[fi2];\n            b.push(c[0], c[1]);\n            face = face2;\n          }\n          // If an oriented center is moving, we need to figure out\n          // the appropriate new orientation.  Normally we use the cubie\n          // sticker identity to locate, but this doesn't work here.\n          // Instead we need to redo the geometry of the sticker itself\n          // rotating and figure out how that maps to the destination\n          // sticker.\n          //\n          // We only need to do this for central center stickers: those\n          // where the face vertex goes through the center.  The others\n          // don't actually need orientation because they can only be\n          // in one orientation by physical constraints.  (You can't spin\n          // a point or cross sticker on the 5x5x5, for example.)\n          //\n          // This also simplifies things because it means the actual\n          // remapping has the same order as the moves themselves.\n          //\n          // The center may or may not have been duplicated at this point.\n          //\n          // The move moving the center might not be the same modulo as the\n          // center itself.\n          if (a.length > 1 && this.orientCenters &&\n              (this.cubies[b[0]].length === 1 ||\n               this.cubies[b[0]][0] === this.cubies[b[0]][1])) {\n             // is this a real center cubie, around an axis?\n             if (centermassface(this.faces[i]).dist(centermassface(this.basefaces[this.getfaceindex(i)])) < eps) {\n               // how does remapping of the face/point set map to the original?\n               let face1 = this.faces[a[0]] ;\n               for (let ii = 0; ii < a.length; ii++) {\n                 const face0 = this.faces[a[ii]] ;\n                 let o = -1 ;\n                 for (let jj = 0; jj < face1.length; jj++) {\n                   if (face0[jj].dist(face1[0]) < eps) {\n                     o = jj ;\n                     break ;\n                   }\n                 }\n                 if (o < 0) {\n                   throw new Error(\"Couldn't find rotation of center faces.\") ;\n                 }\n                 b[2 * ii + 1] = o ;\n                 face1 = this.moverotations[k][0].rotateface(face1) ;\n               }\n             }\n          }\n          // a.length == 1 means a sticker is spinning in place.\n          // in this case we add duplicate stickers and fake the orientation\n          // so that we can make it animate properly in a 3D world.\n          if (a.length === 1 && this.orientCenters) {\n            for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n              a.push(a[0]);\n              if (sc === 0) {\n                b.push(b[0], ii);\n              } else {\n                b.push(b[0], (this.movesetorders[k] - ii) % this.movesetorders[k]);\n              }\n              this.cubies[b[0]].push(this.cubies[b[0]][0]);\n            }\n            this.duplicatedFaces[a[0]] = this.movesetorders[k];\n            this.duplicatedCubies[b[0]] = this.movesetorders[k];\n            this.orbitoris[this.cubiesetnums[b[0]]] = this.movesetorders[k];\n          }\n          if (a.length > 1) {\n            slicemoves.push(a);\n          }\n          if (b.length > 2 && !cubiedone[b[0]]) {\n            slicecmoves.push(b);\n          }\n          for (let j = 0; j < b.length; j += 2) {\n            cubiedone[b[j]] = true;\n          }\n        }\n        axismoves.push(slicemoves);\n        axiscmoves.push(slicecmoves);\n      }\n      movesbyslice.push(axismoves);\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.movesbyslice = movesbyslice;\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.movelist !== undefined) {\n      const parsedmovelist: any[] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (let i = 0; i < this.movelist.length; i++) {\n        parsedmovelist.push(this.parsemove(this.movelist[i]));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n  }\n\n  public getfaces(): number[][][] { // get the faces for 3d.\n    return this.faces.map((_) => {\n      return _.map((__) => [__.b, __.c, __.d]);\n    });\n  }\n\n  public getboundarygeometry(): any { // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  public getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    if (slices > 30) {\n      throw new Error(\"Too many slices for getmovesets bitmasks\");\n    }\n    let r = [];\n    if (this.parsedmovelist !== undefined) {\n      for (let i = 0; i < this.parsedmovelist.length; i++) {\n        const parsedmove = this.parsedmovelist[i];\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push((2 << parsedmove[3]) - (1 << parsedmove[2]));\n        } else {\n          r.push((2 << (slices - parsedmove[2])) - (1 << (slices - parsedmove[3])));\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.vertexmoves && !this.allmoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.outerblockmoves) {\n              r.push((2 << slices) - (2 << i));\n            } else {\n              r.push(2 << i);\n            }\n            r.push(1);\n          } else {\n            if (this.outerblockmoves) {\n              r.push((2 << i) - 1);\n            } else {\n              r.push(1 << i);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.allmoves && i + i === slices) {\n          continue;\n        }\n        if (this.outerblockmoves) {\n          if (i + i > slices) {\n            r.push((2 << slices) - (1 << i));\n          } else {\n            r.push((2 << i) - 1);\n          }\n        } else {\n          r.push(1 << i);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = 1 << +this.cubiekeys[this.fixedCubie].trim().split(\" \")[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (o & dep) {\n          o = (2 << slices) - 1 - o;\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (newr[j] === o && newr[j + 1] === r[i + 1]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    if (this.addrotations) {\n      r.push((2 << slices) - 1);\n      r.push(1);\n    }\n    return r;\n  }\n\n  public graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ((ori === 1 && (this.graycenters || !this.centersets)) ||\n      (ori === 2 && (this.grayedges || !this.edgesets)) ||\n      (ori > 2 && (this.graycorners || !this.cornersets)));\n  }\n\n  public skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return ((ori === 1 && !this.centersets) ||\n      (ori === 2 && !this.edgesets) ||\n      (ori > 2 && !this.cornersets));\n  }\n\n  public skipcubie(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(fi);\n  }\n\n  public skipset(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(this.facetocubies[fi][0]);\n  }\n\n  public header(comment: string): string {\n    return comment + copyright + \"\\n\" +\n      comment + this.args + \"\\n\";\n  }\n\n  public writegap(): string { // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      const movename = \"M_\" + os.movenames[i];\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\"ip:=[\" + ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").\n      join(\",\") + \"];\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\", fortwisty: boolean = false): string {\n    const od = this.getOrbitsDef(fortwisty);\n    if (fortwisty) {\n      return od.toKsolve(name, fortwisty).join(\"\\n\");\n    } else {\n      return this.header(\"# \") + od.toKsolve(name, fortwisty).join(\"\\n\");\n    }\n  }\n  public writekpuzzle(fortwisty: boolean = true): any {\n    return this.getOrbitsDef(fortwisty).toKpuzzle();\n  }\n\n  public getOrbitsDef(fortwisty: boolean): OrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    const setnames: string[] = [];\n    const setdefs: OrbitDef[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i] === moveset[j] && moveset[i + 1] === moveset[j + 1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      let allbits = 0;\n      for (let i = 0; i < moveset.length; i += 2) {\n        allbits |= moveset[i];\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (((allbits >> i) & 1) === 0) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j++) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j][0]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(new OrbitDef(this.cubieords[i],\n        this.killorientation ? 1 : this.orbitoris[i]));\n    }\n    const solved: Orbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(new Orbit(p, o,\n        this.killorientation ? 1 : this.orbitoris[i]));\n    }\n    const movenames: string[] = [];\n    const moves: Transformation[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slices = moveplaneset.length;\n      const moveset = this.getmovesets(k);\n      const movesetgeo = this.movesetgeos[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        const movebits = moveset[i];\n        const mna = getmovename(movesetgeo, movebits, slices);\n        const movename = mna[0];\n        const inverted = mna[1];\n        movenames.push(movename);\n        const moveorbits: Orbit[] = [];\n        const perms = [];\n        const oris = [];\n        for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n          const p = [];\n          for (let kk = 0; kk < this.cubieords[ii]; kk++) {\n            p.push(kk);\n          }\n          perms.push(p);\n          const o = [];\n          for (let kk = 0; kk < this.cubieords[ii]; kk++) {\n            o.push(0);\n          }\n          oris.push(o);\n        }\n        const axiscmoves = this.cmovesbyslice[k];\n        for (let m = 0; m < axiscmoves.length; m++) {\n          if (((movebits >> m) & 1) === 0) {\n            continue;\n          }\n          const slicecmoves = axiscmoves[m];\n          for (let j = 0; j < slicecmoves.length; j++) {\n            const mperm = slicecmoves[j].slice();\n            const setnum = this.cubiesetnums[mperm[0]];\n            for (let ii = 0; ii < mperm.length; ii += 2) {\n              mperm[ii] = this.cubieordnums[mperm[ii]];\n            }\n            let inc = 2;\n            let oinc = 3;\n            if (inverted) {\n              inc = mperm.length - 2;\n              oinc = mperm.length - 1;\n            }\n            for (let ii = 0; ii < mperm.length; ii += 2) {\n              perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n              if (this.killorientation) {\n                oris[setnum][mperm[ii]] = 0;\n              } else {\n                oris[setnum][mperm[ii]] =\n                  (mperm[(ii + oinc) % mperm.length] -\n                    mperm[(ii + 1) % mperm.length] +\n                    this.orbitoris[setnum]) % this.orbitoris[setnum];\n              }\n            }\n          }\n        }\n        for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n          if (!setmoves[ii]) {\n            continue;\n          }\n          const no = new Array<number>(oris[ii].length);\n          // convert ksolve oris to our internal ori rep\n          for (let jj = 0; jj < perms[ii].length; jj++) {\n            no[jj] = oris[ii][perms[ii][jj]];\n          }\n          moveorbits.push(new Orbit(perms[ii], no,\n            this.killorientation ? 1 : this.orbitoris[ii]));\n        }\n        let mv = new Transformation(moveorbits);\n        if (moveset[i + 1] !== 1) {\n          mv = mv.mulScalar(moveset[i + 1]);\n        }\n        moves.push(mv);\n      }\n    }\n    this.ksolvemovenames = movenames; // hack!\n    let r = new OrbitsDef(setnames, setdefs, new VisibleState(solved),\n      movenames, moves);\n    if (this.optimize) {\n      r = r.optimize();\n    }\n    if (this.scramble !== 0) {\n      r.scramble(this.scramble);\n    }\n    return r;\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.\n      map((_: Transformation) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm { // get a solved position\n    const r = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  public getInitial3DRotation() {\n    const basefacecount = this.basefacecount;\n    if (basefacecount === 4) {\n      return new Quat(0.7043069543230507, 0.0617237605829268,\n        0.4546068756768417, 0.5417328493446099);\n    } else if (basefacecount === 6) {\n      return new Quat(0.3419476009844782, 0.17612448544695208,\n        -0.42284908551877964, 0.8205185279339757);\n    } else if (basefacecount === 8) {\n      return new Quat(-0.6523285484575103, 0.2707374015470506,\n        0.6537994145576647, 0.27150515611112014);\n    } else if (basefacecount === 12) {\n      return new Quat(-0.5856747836703331, 0.02634133605619232,\n        0.7075560342412421, 0.39453217891103587);\n    } else if (basefacecount === 20) {\n      return new Quat(0.7052782621769977, 0.6377976252204238,\n        0.30390357803973855, 0.05864620549043545);\n    } else {\n      throw new Error(\"Wrong base face count\");\n    }\n  }\n\n  public generatesvg(w: number = 800, h: number = 500, trim: number = 10, threed: boolean = false): string {\n    // generate svg to interoperate with Lucas twistysim\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = 2 * Math.PI / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // if we don't add this noise to coordinate values, then Safari\n    // doesn't render our polygons correctly.  What a hack.\n    function noise(c: number): number {\n      return c + 0 * (Math.random() - 0.5);\n    }\n    function drawedges(id: string, pts: number[][], color: string)\n      : string {\n      return \"<polygon id=\\\"\" + id + \"\\\" class=\\\"sticker\\\" style=\\\"fill: \" + color +\n        \"\\\" points=\\\"\" +\n        pts.map((p) => noise(p[0]) + \" \" + noise(p[1])).join(\" \") +\n        \"\\\"/>\\n\";\n    }\n    // What grips do we need?  if rotations, add all grips.\n    let needvertexgrips = this.addrotations;\n    let neededgegrips = this.addrotations;\n    let needfacegrips = this.addrotations;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      for (let j = 1; j <= 3; j += 2) {\n        if (msg[j] === \"v\") {\n          needvertexgrips = true;\n        }\n        if (msg[j] === \"f\") {\n          needfacegrips = true;\n        }\n        if (msg[j] === \"e\") {\n          neededgegrips = true;\n        }\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [[1, 0], [0, 0]];\n    extendedges(edges[net[0][0]], polyn);\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (let i = 0; i < es.length; i++) {\n        minx = Math.min(minx, es[i][0]);\n        maxx = Math.max(maxx, es[i][0]);\n        miny = Math.min(miny, es[i][1]);\n        maxy = Math.max(maxy, es[i][1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: any = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [[sc + xoff, yoff], [xoff, yoff]];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0,\n      [new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0)]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [edges2[f0][j % polyn], edges2[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn].sum(thisface[(caf0 + j + polyn - 1) % polyn]).smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[(f0 === el[0]) ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k,\n              [new Quat(0, p2[0], p2[1], 0), new Quat(0, p1[0], p1[1], 0)]);\n            break;\n          }\n        }\n      }\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      face = rot.rotateface(face);\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face[j].b));\n        hiy = Math.max(hiy, Math.abs(face[j].c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const that = this;\n    function mappt2d(fn: number, q: Quat): number[] {\n      if (threed) {\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = (that.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1);\n        return [trim + w * 0.5 + xmul * (xoff2 - q.b * sc2), trim + h * 0.5 + q.c * sc2];\n      } else {\n        const g = geos[that.facenames[fn][1]];\n        return [trim + q.dot(g[0]) + g[2].b, trim + h - q.dot(g[1]) - g[2].c];\n      }\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = that.faces[i];\n      const facenum = Math.floor(i / that.stickersperface);\n      if (threed) {\n        face = rot.rotateface(face);\n      }\n      facegeo.push(face.map((_: Quat) => mappt2d(facenum, _)));\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.basefacecount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubies[i][0];\n        const cubieori = this.facetocubies[i][1];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id = this.cubiesetnames[cubiesetnum] +\n          \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] +\n              \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const svggrips: any[] = [];\n    function addgrip(onface: number, name: string, pt: Quat, order: number): void {\n      const pt2 = mappt2d(onface, pt);\n      for (let i = 0; i < svggrips.length; i++) {\n        if (Math.hypot(pt2[0] - svggrips[i][0], pt2[1] - svggrips[i][1]) < eps) {\n          return;\n        }\n      }\n      svggrips.push([pt2[0], pt2[1], name, order]);\n    }\n    for (let i = 0; i < this.faceplanes.length; i++) {\n      const baseface = this.facenames[i][0];\n      let facecoords = baseface;\n      if (threed) {\n        facecoords = rot.rotateface(facecoords);\n      }\n      if (needfacegrips) {\n        let pt = this.faceplanes[i][0];\n        if (threed) {\n          pt = pt.rotatepoint(rot);\n        }\n        addgrip(i, this.faceplanes[i][1], pt, polyn);\n      }\n      for (let j = 0; j < baseface.length; j++) {\n        if (neededgegrips) {\n          const mp = baseface[j].sum(\n            baseface[(j + 1) % baseface.length]).smul(0.5);\n          const ep = findelement(this.edgenames, mp);\n          const mpc = facecoords[j].sum(\n            facecoords[(j + 1) % baseface.length]).smul(0.5);\n          addgrip(i, this.edgenames[ep][1], mpc, 2);\n        }\n        if (needvertexgrips) {\n          const vp = findelement(\n            this.vertexnames, baseface[j]);\n          addgrip(i, this.vertexnames[vp][1], facecoords[j],\n            this.cornerfaces);\n        }\n      }\n    }\n    const html = '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") + \"</svg>\";\n    this.svggrips = svggrips;\n    return html;\n  }\n\n  public get3d(trim?: number): StickerDat {\n    const stickers: any = [];\n    const rot = this.getInitial3DRotation();\n    const faces: any = [];\n    const maxdist: number = 0.52 * this.basefaces[0][0].len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = rot.rotateface(this.basefaces[i]);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubies[i][0];\n      const cubieori = this.facetocubies[i][1];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      const color = this.graybyori(cubie) ? \"#808080\" :\n        this.colors[this.facenames[facenum][1]];\n      let coords = rot.rotateface(this.faces[i]);\n      if (trim && trim > 0) {\n        coords = trimEdges(coords, trim);\n      }\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color, orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord, ori: cubieori,\n      });\n      if (this.duplicatedFaces[i]) {\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          stickers.push({\n            coords: toFaceCoords(coords, maxdist),\n            color, orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord, ori: jj,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const gn = this.geonormals[j];\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push([toCoords(gn[0].rotatepoint(rot), 1),\n          msg[0], order]);\n          grips.push([toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n          msg[2], order]);\n        }\n      }\n    }\n    return { stickers, faces, axis: grips };\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n}\n","import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += \"^\" + this.mult[i];\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): number {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): number {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = 1;\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = 1;\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= cnt;\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\"\" + i + \": sz \" + sz + \" T \" + tks + \" sol \" + sollen + \" none \" + none + \" mults \" + mults);\n    }\n    return sz;\n  }\n  return getsgs();\n}\n"],"names":["iota","n","c","Array","i","lcm","a","b","t","m","gcd","Perm","[object Object]","this","length","p","join","p2","cyc","seen","incyc","j","push","r","cs","OrbitDef","size","mod","factorial","Math","pow","OrbitsDef","orbitnames","orbitdefs","solved","movenames","moveops","name","forTwisty","result","o","orbits","toKsolveVS","isIdentity","toKsolve","start","numPieces","orientations","toKpuzzle","moves","mp","startPieces","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","DisjointUnion","changed","k","perm","ori","union","keepori","duo","find","nontriv","multiple","h","no","on","nv","remapVS","remap","killOri","VisibleState","map","_","Transformation","pool","floor","random","ri","rj","rm","mul","s","reassemblySize","Orbit","orimod","zeros","newPerm","newOri","done","v","undefined","toPerm","order","nextNew","reassign","ov","newori","permutation","orientation","TransformationBase","newOrbits","inv","equal","perms","identicalPieces","super","internalMul","e","internalInv","heads","ah","bh","centermassface","face","Quat","sum","smul","solvethreeplanes","p1","p3","planes","intersect3","dt","d","q","hypot","sqrt","dot","normalize","acos","a00","a01","a02","a10","a11","a12","a20","a21","a22","invrot","that","rotatepoint","cubie","rotateface","det","det3x3","abs","x","faces","nfaces","inout","side","nface","kk","vk","pt","Error","dist","uniqueplanes","g","planerot","rotateplane","wasseen","getface","cross","Puzzles","2x2x2","3x3x3","4x4x4","5x5x5","6x6x6","7x7x7","8x8x8","9x9x9","10x10x10","11x11x11","12x12x12","13x13x13","20x20x20","30x30x30","skewb","master skewb","professor skewb","compy cube","helicopter","dino","little chop","pyramorphix","mastermorphix","pyraminx","master pyraminx","professor pyraminx","Jing pyraminx","master pyramorphix","megaminx","gigaminx","pentultimate","starminx","starminx 2","pyraminx crystal","chopasaurus","big chop","skewb diamond","FTO","Christopher's jewel","octastar","Trajber's octahedron","radio chop","icosamate","icosahedron 2","icosahedron 3","icosahedron static faces","icosahedron moving faces","Eitan's star","2x2x2 + dino","2x2x2 + little chop","dino + little chop","2x2x2 + dino + little chop","megaminx + chopasaurus","starminx combo","defaultnets","4","6","8","12","20","defaultcolors","F","D","L","R","U","B","BB","BL","BR","C","A","E","BF","I","G","S","H","J","K","M","O","P","N","Q","defaultfaceorders","findelement","getpuzzles","getpuzzle","puzzleName","parsedesc","split","filter","Boolean","getPuzzleGeometryByDesc","desc","options","shape","cuts","pg","PuzzleGeometry","concat","allstickers","genperms","getPuzzleGeometryByName","getmovename","geo","bits","slices","nbits","inverted","movenameFamily","movenamePrefix","hibit","String","toLowerCase","splitByFaceNames","facenames","at","found","substr","startsWith","toCoords","maxdist","toFaceCoords","trimEdges","tr","iter","pi","ni","sub","good","optionlist","verbose","allmoves","outerblockmoves","vertexmoves","addrotations","cornersets","centersets","edgesets","graycorners","graycenters","grayedges","movelist","killorientation","optimize","scramble","fixPiece","orientCenters","args","console","log","header","create","moveplanes","cubies","s5","cube","octahedron","dx","dy","dd","ang","PI","cos","sin","icosahedron","d36","dodecahedron","rotations","ns","negns","closure","baseplane","baseplanerot","baseplanes","basefacecount","net","colors","faceorder","baseface","facenormal","makenormal","edgenormal","vertexnormal","cutplanes","normal","makecut","boundary","basefaces","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","jj","otherfaces","facelist","el","facenametoindex","faceindextoname","fi","ii","fn2","of","faceprecedence","faceplane","facename","midpoint","jjj","midpoint2","e1","e2","c1","c2","cornerfaces","st","geonormals","zero","edgedistance","vertexdistance","sameplane","cutfaces","stickersperface","shortedge","moveplanesets","faceside","facetocubies","findface","cm","key","keyface","facelisthash","face2","facen","edgen","targvec","edgen2","plane","x0","olen","len","y0","delta","cosr","sinr","x1","y1","off","rots","expandfaces","qnormal","normalizeplane","goodnormal","sort","sizes","moverotations","angle","reverse","sizes2","movesetorders","movesetgeos","p0","neg","pos","cubiehash","cubiekey","cubiekeys","suff","s2","Object","keys","cmall","looplimit","u","mini","minf","temp","getfaceindex","ocubie","slice","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","cubiesetcubies","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","tq","findcubie","fixedCubie","mv","re","RegExp","match","grip","fullrotation","endsWith","msi","upperCaseGrip","toUpperCase","firstgrip","spinmatch","loslice","hislice","parseInt","amountstr","amount","substring","cmovesbyslice","movesbyslice","moveplaneset","slicenum","slicecnts","axismoves","axiscmoves","sc","slicemoves","slicecmoves","cubiedone","fi2","face1","face0","duplicatedFaces","duplicatedCubies","parsedmovelist","parsemove","__","parsedmove","msg","dep","trim","newr","set","skipbyori","comment","os","getOrbitsDef","mvs","movename","toGap","ip","fortwisty","od","setmoves","setnames","setdefs","moveset","getmovesets","allbits","skipcubie","movesetgeo","movebits","mna","moveorbits","oris","mperm","setnum","inc","oinc","mulScalar","ksolvemovenames","disp","orders","commutes","permA","permB","curlev","0","nextlev","uniq","sti","cnt","nst","showcanon","w","threed","extendedges","cosa","sina","ndx","noise","drawedges","id","pts","color","needvertexgrips","neededgegrips","needfacegrips","polyn","getboundarygeometry","edges","minx","miny","maxx","maxy","f0","f1","f","es","min","max","xoff","yoff","geos","bg","edges2","initv","project2d","connectat","gfi","thisface","caf0","epi","gf1","gf1i","otherface","getsolved","colormap","facegeo","hix","hiy","rot","getInitial3DRotation","sc2","mappt2d","fn","xoff2","xmul","facenum","svg","cubieori","cubieord","graybyori","svggrips","addgrip","onface","pt2","facecoords","ep","mpc","vp","html","stickers","coords","orbit","ord","grips","gn","axis","divid","FactoredNumber","mult","schreierSims","identity","sgs","sgsi","sgslen","Tk","Tklen","knutha","knuthb","resolve","none","sz","tks","sollen","mults","lensum","multiply","getsgs"],"mappings":"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"}