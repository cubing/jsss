{"version":3,"file":"index-bceade28.js","sources":["../../src/kpuzzle/kpuzzle.ts","../../src/kpuzzle/definitions/index.ts","../../src/kpuzzle/puzzle_definitions.ts","../../src/kpuzzle/parser/parser.js","../../src/kpuzzle/svg.ts"],"sourcesContent":["import { BlockMove, blockMoveToString, expand, parse, Sequence } from \"../alg\";\nimport { KPuzzleDefinition, Transformation } from \"./definition_types\";\n\nexport function Combine(def: KPuzzleDefinition, t1: Transformation, t2: Transformation): Transformation {\n  const newTrans: Transformation = {} as Transformation;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o1 = t1[orbitName];\n    const o2 = t2[orbitName];\n    const newPerm = new Array(oDef.numPieces);\n    const newOri = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      newOri[idx] = (o1.orientation[o2.permutation[idx]] + o2.orientation[idx])\n        % oDef.orientations;\n      newPerm[idx] = o1.permutation[o2.permutation[idx]];\n    }\n    newTrans[orbitName] = { permutation: newPerm, orientation: newOri };\n  }\n  return newTrans;\n}\n\nexport function Multiply(def: KPuzzleDefinition, t: Transformation, amount: number): Transformation {\n  if (amount < 0) {\n    return Multiply(def, Invert(def, t), -amount);\n  }\n  if (amount === 0) {\n    return IdentityTransformation(def);\n  }\n  if (amount === 1) {\n    return t;\n  }\n  const halfish = Multiply(def, t, Math.floor(amount / 2));\n  const twiceHalfish = Combine(def, halfish, halfish);\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return Combine(def, t, twiceHalfish);\n  }\n}\nexport function IdentityTransformation(definition: KPuzzleDefinition): Transformation {\n  const transformation = {} as Transformation;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const newPermutation = new Array(orbitDefinition.numPieces);\n    const newOrientation = new Array(orbitDefinition.numPieces);\n    for (let i = 0; i < orbitDefinition.numPieces; i++) {\n      newPermutation[i] = i;\n      newOrientation[i] = 0;\n    }\n    const orbitTransformation = { permutation: newPermutation, orientation: newOrientation };\n    transformation[orbitName] = orbitTransformation;\n  }\n  return transformation;\n}\n\nexport function Invert(def: KPuzzleDefinition, t: Transformation): Transformation {\n  const newTrans: Transformation = {} as Transformation;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o = t[orbitName];\n    const newPerm = new Array(oDef.numPieces);\n    const newOri = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      const fromIdx = (o.permutation[idx] as number);\n      newPerm[fromIdx] = idx;\n      newOri[fromIdx] = (oDef.orientations - o.orientation[idx] + oDef.orientations) % oDef.orientations;\n    }\n    newTrans[orbitName] = { permutation: newPerm, orientation: newOri };\n  }\n  return newTrans;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n/* calculate the order of a particular transformation. */\nexport function Order(def: KPuzzleDefinition, t: Transformation): number {\n  let r: number = 1;\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o = t[orbitName];\n    const d = new Array(oDef.numPieces);\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      if (!d[idx]) {\n        let w = idx;\n        let om = 0;\n        let pm = 0;\n        while (true) {\n          d[w] = true;\n          om = om + o.orientation[w];\n          pm = pm + 1;\n          w = o.permutation[w];\n          if (w === idx) {\n            break;\n          }\n        }\n        if (om !== 0) {\n          pm = pm * oDef.orientations / gcd(oDef.orientations, om);\n        }\n        r = r * pm / gcd(r, pm);\n      }\n    }\n  }\n  return r;\n}\n\nexport function EquivalentTransformations(def: KPuzzleDefinition, t1: Transformation, t2: Transformation): boolean {\n  for (const orbitName in def.orbits) {\n    const oDef = def.orbits[orbitName];\n    const o1 = t1[orbitName];\n    const o2 = t2[orbitName];\n    for (let idx = 0; idx < oDef.numPieces; idx++) {\n      if (o1.orientation[idx] !== o2.orientation[idx]) {\n        return false;\n      }\n      if (o1.permutation[idx] !== o2.permutation[idx]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport function EquivalentStates(def: KPuzzleDefinition, t1: Transformation, t2: Transformation): boolean {\n  // Turn transformations into states.\n  // This accounts for indistinguishable pieces.\n  return EquivalentTransformations(def, Combine(def, def.startPieces, t1), Combine(def, def.startPieces, t2));\n}\n\n// TODO: Move other helpers into the definition.\nexport function stateForBlockMove(def: KPuzzleDefinition, blockMove: BlockMove): Transformation {\n  // TODO: Optimize this.\n  const repMoveString = blockMoveToString(new BlockMove(blockMove.outerLayer, blockMove.innerLayer, blockMove.family, 1));\n  let move: Transformation | undefined = def.moves[repMoveString];\n  if (!move) {\n    move = new KPuzzle(def).expandSlices(repMoveString, blockMove);\n  }\n  if (!move) {\n    throw new Error(`Unknown move family: ${blockMove.family}`);\n  }\n  return Multiply(def, move, blockMove.amount);\n}\n\nexport class KPuzzle {\n  public state: Transformation;\n  constructor(public definition: KPuzzleDefinition) {\n    this.state = IdentityTransformation(definition);\n  }\n\n  public reset(): void {\n    this.state = IdentityTransformation(this.definition);\n  }\n\n  public serialize(): string {\n    let output = \"\";\n    for (const orbitName in this.definition.orbits) {\n      output += orbitName + \"\\n\";\n      output += this.state[orbitName].permutation.join(\" \") + \"\\n\";\n      output += this.state[orbitName].orientation.join(\" \") + \"\\n\";\n    }\n    output = output.slice(0, output.length - 1); // Trim last newline.\n    return output;\n  }\n\n  public applyBlockMove(blockMove: BlockMove): void {\n    this.state = Combine(this.definition, this.state, stateForBlockMove(this.definition, blockMove));\n  }\n\n  public applyAlg(a: Sequence): void {\n    // TODO: Iterator instead of full expansion.\n    for (const move of (expand(a).nestedUnits) as BlockMove[]) {\n      this.applyBlockMove(move);\n    }\n  }\n\n  public applyMove(moveName: string): this {\n    let move: Transformation | undefined = this.definition.moves[moveName];\n    if (!move) {\n      move = this.expandSlicesByName(moveName);\n    }\n    if (!move) {\n      throw new Error(`Unknown move: ${moveName}`);\n    }\n\n    this.state = Combine(this.definition, this.state, move);\n    return this;\n  }\n\n  public getMoveExpander(create: boolean): MoveExpander | undefined {\n    let moveExpander = this.definition.moveExpander;\n    if (create && !moveExpander) {\n      moveExpander = new MoveExpander();\n      this.definition.moveExpander = moveExpander;\n    }\n    return moveExpander;\n  }\n  public setFaceNames(faceNames: string[]): void {\n    const me = this.getMoveExpander(true);\n    if (me) {\n      me.setFaceNames(faceNames);\n    }\n  }\n  public addGrip(grip1: string, grip2: string, nslices: number): void {\n    const me = this.getMoveExpander(true);\n    return me ? me.addGrip(grip1, grip2, nslices, this.definition) : undefined;\n  }\n  public expandSlices(rep: string, blockMove: BlockMove): Transformation | undefined {\n    const me = this.getMoveExpander(false);\n    return me ? me.expandSlices(rep, blockMove, this.definition) : undefined;\n  }\n  public expandSlicesByName(mv: string): Transformation | undefined {\n    const me = this.getMoveExpander(false);\n    return me ? me.expandSlicesByName(mv, this.definition) : undefined;\n  }\n  public unswizzle(grip: string): string {\n    const me = this.getMoveExpander(true);\n    return me ? me.unswizzle(grip) : grip;\n  }\n\n  // TODO: Implement\n  // parseState(): this {}\n\n  // TODO: Alg parsing\n\n  // TODO: Implement.\n  // invert(): this {}\n}\n\n//   This class supports expanding a set of slice moves (for instance,\n//   U, 2U, 3U, 2D, D on the 5x5x5) into a full set of outer block, inner\n//   slice, etc. moves such as 2-3u or 5U, automatically.  The addGrip()\n//   method informs us what grips exist and how many slices there are.\n//   The setFaceNames() method tells us what the names of the faces are\n//   so we can unswizzle swizzled grip names.\n\nexport class MoveExpander {\n  private gripStash: { [key: string]: Transformation[] };\n  private moveStash: { [key: string]: Transformation };\n  private facenames?: string[];\n  private regrip: { [key: string]: string };\n  constructor() {\n    this.gripStash = {};\n    this.moveStash = {};\n    this.regrip = {};\n  }\n  public setFaceNames(fn: string[]): void {\n    this.facenames = fn;\n  }\n  public addGrip(grip1: string, grip2: string, nslices: number, def: KPuzzleDefinition): void {\n    const slices = [];\n    const axes = this.gripStash;\n    const moves = def.moves;\n    for (let i = 1; i <= nslices; i++) {\n      let t = (i === 1 && moves[grip1]) || moves[\"\" + i + grip1];\n      if (!t) {\n        t = (i === nslices && moves[grip2] || moves[\"\" + (nslices + 1 - i) + grip2]);\n        if (t) {\n          t = Invert(def, t);\n        }\n      }\n      if (!t) {\n        throw new Error(\"Could not expand axis \" + grip1 + \" to \" + grip2 +\n          \" because we are missing a move for slice \" + i);\n      }\n      slices.push(t);\n    }\n    axes[grip1] = slices;\n    const aprime = slices.map((_: Transformation) => Invert(def, _));\n    aprime.reverse();\n    axes[grip2] = aprime;\n  }\n  public expandSlicesByName(mv: string, def: KPuzzleDefinition): Transformation | undefined {\n    const t = this.moveStash[mv];\n    if (t) {\n      return t;\n    }\n    try {\n      const alg = parse(mv);\n      if (alg.nestedUnits.length !== 1) {\n        return undefined;\n      }\n      const signmove = alg.nestedUnits[0] as BlockMove; // need better way\n      return this.expandSlices(mv, signmove, def);\n    } catch (e) {\n      return undefined;\n    }\n  }\n  public unswizzle(grip: string): string {\n    if (this.regrip[grip]) {\n      return this.regrip[grip];\n    }\n    if (!this.facenames) {\n      return grip;\n    }\n    // permit unswizzle to strip w and p suffixes for callers\n    // other than the internal move expander below.\n    if (grip.length > 1) {\n      if (grip[0] <= \"Z\" && (grip[grip.length - 1] === \"w\" || grip[grip.length - 1] === \"v\")) {\n        grip = grip.substr(0, grip.length - 1);\n      }\n    }\n    const faceSplit = this.splitByFaceNames(grip, this.facenames);\n    if (faceSplit) {\n      for (let i = 0; i < faceSplit.length; i++) {\n        let testGrip = \"\";\n        for (let j = 0; j < faceSplit.length; j++) {\n          testGrip += faceSplit[(i + j) % faceSplit.length];\n        }\n        if (this.gripStash[testGrip]) {\n          this.regrip[grip] = testGrip;\n          return testGrip;\n        }\n      }\n    }\n    return grip;\n  }\n  public expandSlices(rep: string, blockMove: BlockMove, def: KPuzzleDefinition): Transformation | undefined {\n    const t = this.moveStash[rep];\n    if (t) {\n      return t;\n    }\n    const axes = this.gripStash;\n    const family = blockMove.family;\n    let grip = family;\n    let isBlock = false;\n    let isPuzzle = false;\n    // the following \"reparse\" code is almost certainly wrong\n    if (/[a-z]/.test(family)) {\n      isBlock = true;\n      grip = family.toUpperCase();\n    }\n    if (family.length > 1 && family.endsWith(\"w\")) {\n      isBlock = true;\n      grip = family.substring(0, family.length - 1);\n    }\n    if (family.length > 1 && family.endsWith(\"v\")) {\n      isPuzzle = true;\n      grip = family.substring(0, family.length - 1);\n    }\n    let slices = axes[grip];\n    if (!slices && this.facenames) {\n      grip = this.unswizzle(grip);\n      slices = axes[grip];\n    }\n    if (!slices) {\n      return undefined;\n    } // don't throw here; let others catch it\n    let outer = blockMove.outerLayer;\n    let inner = blockMove.innerLayer;\n    if (inner === undefined) {\n      if (outer === undefined) {\n        outer = 1;\n        inner = (isBlock ? 2 : 1);\n        if (isPuzzle) {\n          inner = axes[grip].length;\n        }\n      } else {\n        return undefined;\n      } // should never happen\n    } else if (outer === undefined) {\n      outer = (isBlock ? 1 : inner);\n    }\n    if (inner < outer) {\n      return undefined;\n    }\n    if (outer > axes[grip].length) {\n      return undefined;\n    }\n    let t2 = slices[outer - 1];\n    for (let i = outer + 1; i <= inner; i++) {\n      t2 = Combine(def, t2, slices[i - 1]);\n    }\n    this.moveStash[rep] = t2;\n    return t2;\n  }\n  private splitByFaceNames(s: string, facenames: string[]): string[] | undefined {\n    const r: string[] = [];\n    let at = 0;\n    // we permit lowercase arguments, but face names are always upper case\n    s = s.toUpperCase();\n    while (at < s.length) {\n      let found = false;\n      for (const facename of facenames) {\n        if (s.substr(at).startsWith(facename)) {\n          r.push(facename);\n          at += facename.length;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return undefined;\n      }\n    }\n    return r;\n  }\n}\n","import { KPuzzleDefinition } from \"../definition_types\";\n\ndeclare module \"*.svg\";\n\n// TODO: Figure out how to import SVGs directly, in a way that works with all our build systems.\n\nimport cube222JSON from \"./2x2x2.kpuzzle.json\";\nexport const Cube222: KPuzzleDefinition = cube222JSON;\nimport cube222SVG from \"./svg/2x2x2.kpuzzle.svg\";\nCube222.svg = cube222SVG;\n// Cube222.svg = svgJSON[\"2x2x2.kpuzzle.svg\"];\n\nimport cube333JSON from \"./3x3x3.kpuzzle.json\";\nexport const Cube333: KPuzzleDefinition = cube333JSON;\nimport cube333SVG from \"./svg/3x3x3.kpuzzle.svg\";\nCube333.svg = cube333SVG;\n// Cube333.svg = svgJSON[\"3x3x3.kpuzzle.svg\"];\n\nimport PyraminxJSON from \"./pyraminx.kpuzzle.json\";\nexport const Pyraminx: KPuzzleDefinition = PyraminxJSON;\nimport pyraminxSVG from \"./svg/pyraminx.kpuzzle.svg\";\nPyraminx.svg = pyraminxSVG;\n\nimport square1JSON from \"./sq1-hyperorbit.kpuzzle.json\";\nexport const Square1: KPuzzleDefinition = square1JSON;\nimport square1SVG from \"./svg/sq1-hyperorbit.kpuzzle.svg\";\nSquare1.svg = square1SVG;\n\nimport clockJSON from \"./clock.kpuzzle.json\";\nexport const Clock: KPuzzleDefinition = clockJSON;\nimport clockSVG from \"./svg/clock.kpuzzle.svg\";\nClock.svg = clockSVG;\n","import { KPuzzleDefinition } from \"./definition_types\";\nimport { Clock, Cube222, Cube333, Pyraminx, Square1 } from \"./definitions\";\n\nexport const Puzzles: { [key: string]: KPuzzleDefinition } = {\n  \"2x2x2\": Cube222,\n  \"3x3x3\": Cube333,\n  \"pyraminx\": Pyraminx,\n  \"sq1\": Square1,\n  \"clock\": Clock,\n};\n","// Workaround per https://github.com/pegjs/pegjs/pull/481\nimport parser from \"./parser.pegjs\";\nconst {parse} = parser;\nexport {parse};\n","import { KPuzzleDefinition, Transformation } from \"./definition_types\";\nimport { KPuzzle } from \"./kpuzzle\";\n\nconst xmlns = \"http://www.w3.org/2000/svg\";\n\n// Unique ID mechanism to keep SVG gradient element IDs unique. TODO: Is there\n// something more performant, and that can't be broken by other elements of the\n// page? (And also doesn't break if this library is run in parallel.)\nlet svgCounter = 0;\nfunction nextSVGID(): string {\n  svgCounter += 1;\n  return \"svg\" + svgCounter.toString();\n}\n\nexport class SVG {\n  public element: HTMLElement;\n  public gradientDefs: SVGDefsElement;\n  private originalColors: { [type: string]: string } = {};\n  private gradients: { [type: string]: SVGGradientElement } = {};\n  private svgID: string;\n  constructor(public kPuzzleDefinition: KPuzzleDefinition) {\n    if (!kPuzzleDefinition.svg) {\n      throw new Error(`No SVG definition for puzzle type: ${kPuzzleDefinition.name}`);\n    }\n\n    this.svgID = nextSVGID();\n\n    this.element = document.createElement(\"div\");\n    this.element.classList.add(\"svg-wrapper\");\n    // TODO: Sanitization.\n    this.element.innerHTML = kPuzzleDefinition.svg;\n\n    const svgElem = this.element.querySelector(\"svg\");\n    if (!svgElem) {\n      throw new Error(\"Could not get SVG element\");\n    }\n    if (xmlns !== svgElem.namespaceURI) {\n      throw new Error(\"Unexpected XML namespace\");\n    }\n    svgElem.style.maxWidth = \"100%\";\n    svgElem.style.maxHeight = \"100%\";\n    this.gradientDefs = document.createElementNS(xmlns, \"defs\") as SVGDefsElement;\n    svgElem.insertBefore(this.gradientDefs, svgElem.firstChild);\n\n    for (const orbitName in kPuzzleDefinition.orbits) {\n      const orbitDefinition = kPuzzleDefinition.orbits[orbitName];\n\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        for (let orientation = 0; orientation < orbitDefinition.orientations; orientation++) {\n          const id = this.elementID(orbitName, idx, orientation);\n          const elem = this.elementByID(id);\n          const originalColor = elem.style.fill as string;\n          this.originalColors[id] = originalColor;\n          this.gradients[id] = this.newGradient(id, originalColor);\n          this.gradientDefs.appendChild(this.gradients[id]);\n          elem.setAttribute(\"style\", `fill: url(#grad-${this.svgID}-${id})`);\n        }\n      }\n    }\n  }\n\n  public drawKPuzzle(kpuzzle: KPuzzle, nextState?: Transformation, fraction?: number): void {\n    this.draw(kpuzzle.definition, kpuzzle.state, nextState, fraction);\n  }\n\n  // TODO: save definition in the constructor?\n  public draw(definition: KPuzzleDefinition, state: Transformation, nextState?: Transformation, fraction?: number): void {\n    for (const orbitName in definition.orbits) {\n      const orbitDefinition = definition.orbits[orbitName];\n\n      const curOrbitState = state[orbitName];\n      const nextOrbitState = nextState ? (nextState as Transformation)[orbitName] : null;\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        for (let orientation = 0; orientation < orbitDefinition.orientations; orientation++) {\n          const id = this.elementID(orbitName, idx, orientation);\n          const fromCur = this.elementID(\n            orbitName,\n            curOrbitState.permutation[idx],\n            (orbitDefinition.orientations - curOrbitState.orientation[idx] + orientation) % orbitDefinition.orientations,\n          );\n          let singleColor = false;\n          if (nextOrbitState) {\n            const fromNext = this.elementID(\n              orbitName,\n              nextOrbitState.permutation[idx],\n              (orbitDefinition.orientations - nextOrbitState.orientation[idx] + orientation) % orbitDefinition.orientations,\n            );\n            if (fromCur === fromNext) {\n              singleColor = true; // TODO: Avoid redundant work during move.\n            }\n            fraction = fraction || 0; // TODO Use the type system to tie this to nextState?\n            const easedBackwardsPercent = 100 * (1 - fraction * fraction * (2 - fraction * fraction)); // TODO: Move easing up the stack.\n            this.gradients[id].children[0].setAttribute(\"stop-color\", this.originalColors[fromCur]);\n            this.gradients[id].children[1].setAttribute(\"stop-color\", this.originalColors[fromCur]);\n            this.gradients[id].children[1].setAttribute(\"offset\", `${Math.max(easedBackwardsPercent - 5, 0)}%`);\n            this.gradients[id].children[2].setAttribute(\"offset\", `${Math.max(easedBackwardsPercent - 5, 0)}%`);\n            this.gradients[id].children[3].setAttribute(\"offset\", `${easedBackwardsPercent}%`);\n            this.gradients[id].children[4].setAttribute(\"offset\", `${easedBackwardsPercent}%`);\n            this.gradients[id].children[4].setAttribute(\"stop-color\", this.originalColors[fromNext]);\n            this.gradients[id].children[5].setAttribute(\"stop-color\", this.originalColors[fromNext]);\n          } else {\n            singleColor = true; // TODO: Avoid redundant work during move.\n          }\n          if (singleColor) {\n            this.gradients[id].children[0].setAttribute(\"stop-color\", this.originalColors[fromCur]);\n            this.gradients[id].children[1].setAttribute(\"stop-color\", this.originalColors[fromCur]);\n            this.gradients[id].children[1].setAttribute(\"offset\", `100%`);\n            this.gradients[id].children[2].setAttribute(\"offset\", `100%`);\n            this.gradients[id].children[3].setAttribute(\"offset\", `100%`);\n            this.gradients[id].children[4].setAttribute(\"offset\", `100%`);\n          }\n          // this.gradients[id]\n          // this.elementByID(id).style.fill = this.originalColors[from];\n        }\n      }\n    }\n  }\n\n  private newGradient(id: string, originalColor: string): SVGGradientElement {\n    const grad = document.createElementNS(xmlns, \"radialGradient\") as SVGGradientElement;\n    grad.setAttribute(\"id\", `grad-${this.svgID}-${id}`);\n    grad.setAttribute(\"r\", `70.7107%`); // TODO: Adapt to puzzle.\n    const stopDefs = [\n      { offset: 0, color: originalColor },\n      { offset: 0, color: originalColor },\n      { offset: 0, color: \"black\" },\n      { offset: 0, color: \"black\" },\n      { offset: 0, color: originalColor },\n      { offset: 100, color: originalColor },\n    ];\n    for (const stopDef of stopDefs) {\n      const stop = document.createElementNS(xmlns,\n        \"stop\") as SVGStopElement;\n      stop.setAttribute(\"offset\", `${stopDef.offset}%`);\n      stop.setAttribute(\"stop-color\", stopDef.color);\n      stop.setAttribute(\"stop-opacity\", \"1\");\n      grad.appendChild(stop);\n    }\n    return grad;\n  }\n\n  private elementID(orbitName: string, idx: number, orientation: number): string {\n    return orbitName + \"-l\" + idx + \"-o\" + orientation;\n  }\n\n  private elementByID(id: string): HTMLElement {\n    // TODO: Use classes and scope selector to SVG element.\n    return this.element.querySelector(\"#\" + id) as HTMLElement;\n  }\n}\n"],"names":["Combine","def","t1","t2","newTrans","orbitName","orbits","oDef","o1","o2","newPerm","Array","numPieces","newOri","idx","orientation","permutation","orientations","Multiply","t","amount","Invert","IdentityTransformation","halfish","Math","floor","twiceHalfish","definition","transformation","orbitDefinition","newPermutation","newOrientation","i","orbitTransformation","o","fromIdx","gcd","a","b","Order","r","d","w","om","pm","EquivalentTransformations","EquivalentStates","startPieces","stateForBlockMove","blockMove","repMoveString","blockMoveToString","BlockMove","outerLayer","innerLayer","family","move","moves","KPuzzle","expandSlices","Error","[object Object]","this","state","output","join","slice","length","expand","applyBlockMove","moveName","expandSlicesByName","create","moveExpander","MoveExpander","faceNames","me","getMoveExpander","setFaceNames","grip1","grip2","nslices","addGrip","undefined","rep","mv","grip","unswizzle","gripStash","moveStash","regrip","fn","facenames","slices","axes","push","aprime","map","_","reverse","alg","parse","nestedUnits","signmove","e","substr","faceSplit","splitByFaceNames","testGrip","j","isBlock","isPuzzle","test","toUpperCase","endsWith","substring","outer","inner","s","at","found","facename","startsWith","Cube222","svg","Cube333","Pyraminx","Square1","Clock","Puzzles","2x2x2","3x3x3","pyraminx","sq1","clock","parser","xmlns","svgCounter","SVG","kPuzzleDefinition","name","svgID","toString","element","document","createElement","classList","add","innerHTML","svgElem","querySelector","namespaceURI","style","maxWidth","maxHeight","gradientDefs","createElementNS","insertBefore","firstChild","id","elementID","elem","elementByID","originalColor","fill","originalColors","gradients","newGradient","appendChild","setAttribute","kpuzzle","nextState","fraction","draw","curOrbitState","nextOrbitState","fromCur","singleColor","fromNext","easedBackwardsPercent","children","max","grad","stopDefs","offset","color","stopDef","stop"],"mappings":"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"}